<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 赵海宇的博客</title>
    <link>/tags/golang/</link>
    <description>Recent content in golang on 赵海宇的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Jan 2022 15:40:42 +0800</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go错误处理</title>
      <link>/post/go-error/</link>
      <pubDate>Sat, 22 Jan 2022 15:40:42 +0800</pubDate>
      
      <guid>/post/go-error/</guid>
      <description>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 创建error 使用errors.New() // New returns an error that formats as the given</description>
    </item>
    
    <item>
      <title>项目目录结构</title>
      <link>/post/project-directory/</link>
      <pubDate>Sun, 02 Jan 2022 17:03:34 +0800</pubDate>
      
      <guid>/post/project-directory/</guid>
      <description>什么是DDD？ DDD 是 Domain-Driven Design 的缩写。 其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散</description>
    </item>
    
    <item>
      <title>Go泛型入门</title>
      <link>/post/go-generics/</link>
      <pubDate>Sat, 25 Dec 2021 18:17:00 +0800</pubDate>
      
      <guid>/post/go-generics/</guid>
      <description>备注：这是一个 beta 版本的内容 这个教程介绍了 Go 泛型的基础概念。 通过泛型，你可以声明并使用函数或者是类型，那些用于调用代码时参数需要兼容多个不同类型的情况。 在这个教程里，你会声明两个普通的函数，然后复制一份</description>
    </item>
    
    <item>
      <title>Nethttp Gin</title>
      <link>/post/nethttp-gin/</link>
      <pubDate>Thu, 16 Dec 2021 22:09:38 +0800</pubDate>
      
      <guid>/post/nethttp-gin/</guid>
      <description>net/http 路由注册 func test1() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;) }) err := http.ListenAndServe(&amp;quot;:9001&amp;quot;, nil) if err != nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li</description>
    </item>
    
    <item>
      <title>Go工程化 - 依赖注入</title>
      <link>/post/wire/</link>
      <pubDate>Mon, 06 Sep 2021 16:06:42 +0800</pubDate>
      
      <guid>/post/wire/</guid>
      <description>我们在微服务框架kratos v2的默认项目模板中kratos-layout使用了google/wire进行依赖注入，也建议开发者在维护项目时使用该工具。 wire 乍看起来比较违反直觉，导致很多同学不理解为什么</description>
    </item>
    
    <item>
      <title>Go Gin框架介绍及使用</title>
      <link>/post/go-gin/</link>
      <pubDate>Sun, 09 May 2021 14:53:19 +0800</pubDate>
      
      <guid>/post/go-gin/</guid>
      <description>Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()</description>
    </item>
    
    <item>
      <title>Go gc垃圾回收</title>
      <link>/post/go-gc/</link>
      <pubDate>Sun, 28 Mar 2021 17:36:55 +0800</pubDate>
      
      <guid>/post/go-gc/</guid>
      <description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。 Golang中的垃圾回收主要应用三色标记法，GC</description>
    </item>
    
    <item>
      <title>Go web源码解析</title>
      <link>/post/go-net-http/</link>
      <pubDate>Sat, 13 Mar 2021 17:35:23 +0800</pubDate>
      
      <guid>/post/go-net-http/</guid>
      <description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;quot;/&amp;quot;, sayHello) err := http.ListenAndServe(&amp;quot;:9090&amp;quot;,nil) if err!=nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;quot;path&amp;quot;,r.URL.Path) fmt.Println(&amp;quot;scheme&amp;quot;,r.URL.Scheme) fmt.Fprintf(w, &amp;quot;Hello Guest!&amp;quot;) } 在使用ListenAndServe这个方法时，系统就会给</description>
    </item>
    
    <item>
      <title>Go zap高性能日志</title>
      <link>/post/go-zap/</link>
      <pubDate>Tue, 12 Jan 2021 11:36:55 +0800</pubDate>
      
      <guid>/post/go-zap/</guid>
      <description>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的</description>
    </item>
    
    <item>
      <title>Go viper配置管理</title>
      <link>/post/go-viper/</link>
      <pubDate>Sat, 02 Jan 2021 11:36:55 +0800</pubDate>
      
      <guid>/post/go-viper/</guid>
      <description>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件 3、应用程序运行过程中，保持监听和重新读取配置文件 4、可以从</description>
    </item>
    
    <item>
      <title>Go操作redis</title>
      <link>/post/go-redis/</link>
      <pubDate>Fri, 01 Jan 2021 17:36:55 +0800</pubDate>
      
      <guid>/post/go-redis/</guid>
      <description>安装 下载第三方包: go get -u github.com/go-redis/redis/v9 连接 // 定义一个rdis客户端 var redisdb *redis.Client // 初始化 func initClient() (err error) { redisdb = redis.NewClient(&amp;amp;redis.Options{ Addr: &amp;quot;localhost:6379&amp;quot;, // post端口 Password: &amp;quot;&amp;quot;, // 密码 DB: 0, // 使用redis的库 }) _, err = redisdb.Ping(context.Background()).Result() if err != nil { fmt.Println(&amp;quot;连接失败</description>
    </item>
    
    <item>
      <title>Go HTML标签提取器soup</title>
      <link>/post/go-soup/</link>
      <pubDate>Sat, 31 Oct 2020 12:52:33 +0800</pubDate>
      
      <guid>/post/go-soup/</guid>
      <description>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树</description>
    </item>
    
    <item>
      <title>Go单元测试</title>
      <link>/post/go-test/</link>
      <pubDate>Wed, 28 Oct 2020 15:33:45 +0800</pubDate>
      
      <guid>/post/go-test/</guid>
      <description>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。 go test</description>
    </item>
    
    <item>
      <title>Go Channel</title>
      <link>/post/go-channel/</link>
      <pubDate>Tue, 27 Oct 2020 15:33:45 +0800</pubDate>
      
      <guid>/post/go-channel/</guid>
      <description>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用</description>
    </item>
    
    <item>
      <title>Go context包</title>
      <link>/post/go-context/</link>
      <pubDate>Sat, 24 Oct 2020 12:26:32 +0800</pubDate>
      
      <guid>/post/go-context/</guid>
      <description>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为： 可以通过context发送取消信号。</description>
    </item>
    
    <item>
      <title>Go Template</title>
      <link>/post/go-template/</link>
      <pubDate>Wed, 21 Oct 2020 17:26:32 +0800</pubDate>
      
      <guid>/post/go-template/</guid>
      <description>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用te</description>
    </item>
    
    <item>
      <title>Go Mod</title>
      <link>/post/go-mod/</link>
      <pubDate>Tue, 20 Oct 2020 17:26:32 +0800</pubDate>
      
      <guid>/post/go-mod/</guid>
      <description>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE 要启用go module支持首先要设置环境变量GO111MODU</description>
    </item>
    
    <item>
      <title>Go Channel源码分析</title>
      <link>/post/go-deep-channel/</link>
      <pubDate>Tue, 31 Mar 2020 17:02:38 +0800</pubDate>
      
      <guid>/post/go-deep-channel/</guid>
      <description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm</description>
    </item>
    
    <item>
      <title>Go fmt包</title>
      <link>/post/go-fmt/</link>
      <pubDate>Fri, 21 Feb 2020 10:26:32 +0800</pubDate>
      
      <guid>/post/go-fmt/</guid>
      <description>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 向外输出 标准库fmt提供了以下几种输出相关函数。 Print Print系列函数会将内容输出到系统的标</description>
    </item>
    
    <item>
      <title>Go time包</title>
      <link>/post/go-time/</link>
      <pubDate>Thu, 20 Feb 2020 11:26:32 +0800</pubDate>
      
      <guid>/post/go-time/</guid>
      <description>时间类型 time.Time类型表示时间。 func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;quot;Now:%v\n&amp;quot;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401 year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) // 2020-08-19 21:53:31 } 时间戳 func stamp() { now :=</description>
    </item>
    
    <item>
      <title>Go Map实现原理</title>
      <link>/post/go-deep-map/</link>
      <pubDate>Wed, 21 Aug 2019 16:55:50 +0800</pubDate>
      
      <guid>/post/go-deep-map/</guid>
      <description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了</description>
    </item>
    
    <item>
      <title>Go文件系统</title>
      <link>/post/go-file/</link>
      <pubDate>Mon, 11 Feb 2019 15:36:17 +0800</pubDate>
      
      <guid>/post/go-file/</guid>
      <description>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;quot;is not exist!&amp;quot;) return false } if os.IsNotExist(err) { return false } return true } 打开文件 f, err := os.Open(filename) if nil != err { fmt.Println(&amp;quot;open&amp;quot;, filename, &amp;quot;failed!&amp;quot;) return } defer f.Close() 如果文件不存在，就会返回错误，如果存在就以只读的方</description>
    </item>
    
    <item>
      <title>Go Reflect</title>
      <link>/post/go-reflect/</link>
      <pubDate>Sat, 09 Feb 2019 15:18:16 +0800</pubDate>
      
      <guid>/post/go-reflect/</guid>
      <description>变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内</description>
    </item>
    
    <item>
      <title>Go并发</title>
      <link>/post/go-concurrent/</link>
      <pubDate>Fri, 08 Feb 2019 15:26:52 +0800</pubDate>
      
      <guid>/post/go-concurrent/</guid>
      <description>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间</description>
    </item>
    
    <item>
      <title>Go接口</title>
      <link>/post/go-interface/</link>
      <pubDate>Mon, 04 Feb 2019 15:22:51 +0800</pubDate>
      
      <guid>/post/go-interface/</guid>
      <description>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 很多面向对象的语言都有相似的接口概念，但Go</description>
    </item>
    
    <item>
      <title>Go方法</title>
      <link>/post/go-method/</link>
      <pubDate>Sat, 02 Feb 2019 15:18:16 +0800</pubDate>
      
      <guid>/post/go-method/</guid>
      <description>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 package main import &amp;quot;fmt&amp;quot; type People struct { name string age uint8 } func (p People) SayHello() { fmt.Println(p.name, &amp;quot;: hello world&amp;quot;) p.age = 20 } func main()</description>
    </item>
    
    <item>
      <title>Go函数</title>
      <link>/post/go-function/</link>
      <pubDate>Fri, 01 Feb 2019 15:03:51 +0800</pubDate>
      
      <guid>/post/go-function/</guid>
      <description>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值</description>
    </item>
    
    <item>
      <title>Go复杂数据结构</title>
      <link>/post/go-complex-structure/</link>
      <pubDate>Mon, 28 Jan 2019 20:38:18 +0800</pubDate>
      
      <guid>/post/go-complex-structure/</guid>
      <description>数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 因为数组的长度是固定的，因此在Go语言中很少直接使用数组。 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0</description>
    </item>
    
    <item>
      <title>Go基础类型</title>
      <link>/post/go-type/</link>
      <pubDate>Sun, 27 Jan 2019 18:22:21 +0800</pubDate>
      
      <guid>/post/go-type/</guid>
      <description>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是</description>
    </item>
    
    <item>
      <title>Go基础结构</title>
      <link>/post/go-infrastructure/</link>
      <pubDate>Sat, 26 Jan 2019 11:18:58 +0800</pubDate>
      
      <guid>/post/go-infrastructure/</guid>
      <description>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的字母、数字或下划线.</description>
    </item>
    
  </channel>
</rss>
