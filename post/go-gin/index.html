<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.100.1"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Go Gin框架介绍及使用 - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta name=keywords content="golang,http"><meta property="og:title" content="Go Gin框架介绍及使用"><meta name=twitter:title content="Go Gin框架介绍及使用"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/go-gin/"><meta property="og:description" content="Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &#34;fmt&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()"><meta name=twitter:description content="Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &#34;fmt&#34; &#34;github.com/gin-gonic/gin&#34; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2021-05-09T14:53:19+08:00"><meta property="article:modified_time" content="2021-05-09T14:53:19+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/go-gin/>Go Gin框架介绍及使用</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-05-09</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3316 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;7 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/golang>golang</a>&nbsp;<a href=/tags/http>http</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=gin框架介绍>Gin框架介绍</h2><ul><li>基于<a href=https://github.com/julienschmidt/httprouter target=_blank>httprouter</a>开发的Web框架。</li><li><a href=https://gin-gonic.com/zh-cn/docs/ target=_blank>中文文档</a>，齐全。</li><li>简单易用的轻量级框架。</li></ul><h2 id=gin框架安装>Gin框架安装</h2><pre><code class=language-bash>go get -u github.com/gin-gonic/gin
</code></pre><p><strong>实例:</strong></p><pre><code class=language-go>package main
import (
    &quot;fmt&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
func main() {

    r := gin.Default()
    // 创建一个默认的路由引擎
    // 也可以用gin.New() gin.Default()多用了日志和panic的recover中间件
    r.GET(&quot;/helloworld&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            // c.JSON：返回JSON格式的数据
            &quot;msg&quot;: &quot;Hello world!&quot;,
        })
    })
    err := r.Run(&quot;127.0.0.1:8001&quot;)
    // 启动HTTP服务，默认在127.0.0.1:8001启动服务
    if err != nil {
        fmt.Println(&quot;run gin field&quot;)
        return
    }
}
</code></pre><p><img class=img-zoomable src=/images/2344773-20210907095947044-1320655711.png alt></p><h2 id=restful-api>RESTful API</h2><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p><p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p><ul><li>GET用来获取资源</li><li>POST用来新建资源</li><li>PUT用来更新资源</li><li>DELETE用来删除资源。</li></ul><p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p><p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>/book</td><td>查询书籍信息</td></tr><tr><td>POST</td><td>/create_book</td><td>创建书籍记录</td></tr><tr><td>POST</td><td>/update_book</td><td>更新书籍信息</td></tr><tr><td>POST</td><td>/delete_book</td><td>删除书籍信息</td></tr></tbody></table><p>同样的需求我们按照RESTful API设计如下：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>/book</td><td>查询书籍信息</td></tr><tr><td>POST</td><td>/book</td><td>创建书籍记录</td></tr><tr><td>PUT</td><td>/book</td><td>更新书籍信息</td></tr><tr><td>DELETE</td><td>/book</td><td>删除书籍信息</td></tr></tbody></table><p>Gin框架支持开发RESTful API的开发。</p><pre><code class=language-go>func main() {
    r := gin.Default()
    r.GET(&quot;/book&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;GET&quot;,
        })
    })
    r.POST(&quot;/book&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;POST&quot;,
        })
    })
    r.PUT(&quot;/book&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;PUT&quot;,
        })
    })
    r.DELETE(&quot;/book&quot;, func(c *gin.Context) {
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;DELETE&quot;,
        })
    })
}
</code></pre><p>开发RESTful API的时候我们通常使用<a href=https://www.getpostman.com/ target=_blank>Postman</a>来作为客户端的测试工具。</p><h2 id=gin渲染>Gin渲染</h2><h3 id=html渲染>HTML渲染</h3><p>我们首先定义一个存放模板文件的templates文件夹，然后在其内部按照业务分别定义一个posts文件夹和一个users文件夹。posts/index.html文件的内容如下：</p><pre><code class=language-go>{{define &quot;posts/index.html&quot;}}
    posts/index
    {{.title}}
{{end}}
</code></pre><p>users/index.html文件的内容如下：</p><pre><code class=language-go>{{define &quot;users/index.html&quot;}}
    users/index
    {{.title}}
{{end}}
</code></pre><p>Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。</p><pre><code class=language-go>func main() {
    r := gin.Default()
    r.LoadHTMLGlob(&quot;templates/**/*&quot;)
    //r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)
    r.GET(&quot;/posts/index&quot;, func(c *gin.Context) {
        c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{
            &quot;title&quot;: &quot;posts/index&quot;,
        })
    })
    r.GET(&quot;users/index&quot;, func(c *gin.Context) {
        c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{
            &quot;title&quot;: &quot;users/index&quot;,
        })
    })
    r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=静态文件处理>静态文件处理</h3><p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用gin.Static方法即可。</p><pre><code class=language-go>func main() {
    r := gin.Default()
    r.Static(&quot;/static&quot;, &quot;./static&quot;)
    r.LoadHTMLGlob(&quot;templates/**/*&quot;)
   ...
    r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=补充文件路径处理>补充文件路径处理</h3><p>关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p><pre><code class=language-go>func getCurrentPath() string {
    if ex, err := os.Executable(); err == nil {
        return filepath.Dir(ex)
    }
    return &quot;./&quot;
}
</code></pre><h3 id=json渲染>JSON渲染</h3><pre><code class=language-go>func main() {
    r := gin.Default()
    // gin.H 是map[string]interface{}的缩写
    r.GET(&quot;/someJSON&quot;, func(c *gin.Context) {
        // 方式一：自己拼接JSON
        c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})
    })
    r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) {
        // 方法二：使用结构体
        var msg struct {
            Name    string `json:&quot;user&quot;`
            Message string
            Age     int
        }
        msg.Name = &quot;zhy&quot;
        msg.Message = &quot;Hello world!&quot;
        msg.Age = 18
        c.JSON(http.StatusOK, msg)
    })
    r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=xml渲染>XML渲染</h3><p>注意需要使用具名的结构体类型。</p><pre><code class=language-go>func main() {
    r := gin.Default()
    // gin.H 是map[string]interface{}的缩写
    r.GET(&quot;/someXML&quot;, func(c *gin.Context) {
        // 方式一：自己拼接JSON
        c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})
    })
    r.GET(&quot;/moreXML&quot;, func(c *gin.Context) {
        // 方法二：使用结构体
        type MessageRecord struct {
            Name    string
            Message string
            Age     int
        }
        var msg MessageRecord
        msg.Name = &quot;小王子&quot;
        msg.Message = &quot;Hello world!&quot;
        msg.Age = 18
        c.XML(http.StatusOK, msg)
    })
    r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=ymal渲染>YMAL渲染</h3><pre><code class=language-go>r.GET(&quot;/someYAML&quot;, func(c *gin.Context) {
    c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK})
})
</code></pre><h3 id=protobuf渲染>protobuf渲染</h3><pre><code class=language-protobuf>// protobuf文件
syntax = &quot;proto3&quot;;
package models;
message hello {
    string content = 1;
}
</code></pre><pre><code class=language-go>package main
import (
    &quot;net/http&quot;
    &quot;test/models&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
func main() {
    r := gin.Default()
    r.GET(&quot;/hello&quot;,func (c *gin.Context)  {
        res := &amp;models.Hello{
            Content: &quot;你好&quot;,
        }
        c.ProtoBuf(http.StatusOK,res)
    })
    _ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h2 id=获取参数>获取参数</h2><h3 id=获取querystring参数>获取querystring参数</h3><p>querystring指的是URL中?后面携带的参数，例如：/user?username=赵海宇&address=地球一角。</p><ol><li>c.DefaultQuery有默认值 如果没有传去默认值</li><li>c.Query没有默认值 如果没传 为空</li></ol><pre><code class=language-go>package main
import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
func main() {
    r := gin.Default()
    r.GET(&quot;/user&quot;, func(c *gin.Context) {
        username := c.DefaultQuery(&quot;username&quot;, &quot;zhy&quot;)
        address := c.Query(&quot;address&quot;)
        c.JSON(http.StatusOK, gin.H{
            &quot;username&quot;: username,
            &quot;address&quot;:  address,
        })
    })
    _ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=获取form参数>获取form参数</h3><p>请求的数据通过form表单来提交，例如向/user发送一个POST请求，获取请求数据的方式如下：c.PostForm</p><pre><code class=language-go>package main
import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
func main() {
    r := gin.Default()
    r.POST(&quot;/user&quot;, func(c *gin.Context) {
        username := c.PostForm(&quot;username&quot;)
        address := c.PostForm(&quot;address&quot;)
        c.JSON(http.StatusOK, gin.H{
            &quot;username&quot;: username,
            &quot;address&quot;:  address,
        })
    })
    _ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=获取path参数>获取path参数</h3><p>请求的参数通过URL路径传递，例如：/user/zhaohaiyu/地球一角/路由:/user/:username/:address方法:c.Param</p><pre><code class=language-go>package main
import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
func main() {
    r := gin.Default()
    r.GET(&quot;/user/:username/:address&quot;, func(c *gin.Context) {
        username := c.Param(&quot;username&quot;)
        address := c.Param(&quot;address&quot;)
        c.JSON(http.StatusOK, gin.H{
            &quot;username&quot;: username,
            &quot;address&quot;:  address,
        })
    })
    _ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=参数绑定>参数绑定</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的content-type识别请求数据类型并利用反射机制自动提取请求中querystring、form表单、JSON、XML等参数到结构体中。</p><pre><code class=language-go>package main
import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)
// Binding from JSON
type Login struct {
    User     string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`
    Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`
}
func main() {
    r := gin.Default()
    // 绑定JSON的示例 ({&quot;user&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123&quot;})
    r.POST(&quot;/loginJSON&quot;, func(c *gin.Context) {
        var login Login
        if err := c.ShouldBindJSON(&amp;login); err == nil {
            fmt.Printf(&quot;login info:%#v\n&quot;, login)
            c.JSON(http.StatusOK, login)
        } else {
            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        }
    })
    // 绑定form表单示例 (user=root&amp;password=123)
    r.POST(&quot;/loginForm&quot;, func(c *gin.Context) {
        var login Login
        // ShouldBind()会根据请求的Content-Type自行选择绑定器
        if err := c.ShouldBind(&amp;login); err == nil {
            c.JSON(http.StatusOK, login)
        } else {
            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        }
    })
    // 绑定querystring示例 (user=root&amp;password=123)
    r.GET(&quot;/loginForm&quot;, func(c *gin.Context) {
        var login Login
        // ShouldBind()会根据请求的Content-Type自行选择绑定器
        if err := c.ShouldBind(&amp;login); err == nil {
            c.JSON(http.StatusOK, login)
        } else {
            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        }
    })
    _ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h2 id=文件上传>文件上传</h2><pre><code class=language-go>func main() {
    router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB
    // 可以通过下面的方式修改
    // router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB
    router.POST(&quot;/upload&quot;, func(c *gin.Context) {
        // 单个文件
        file, err := c.FormFile(&quot;file&quot;)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{&quot;message&quot;: err.Error()})
            return
        }
        log.Println(file.Filename)
        dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename) // 上传文件到指定的目录
        c.SaveUploadedFile(file, dst)
        c.JSON(http.StatusOK, gin.H{&quot;message&quot;: fmt.Sprintf(&quot;'%s' uploaded!&quot;, file.Filename)})
    })
    router.Run()
}
</code></pre><h3 id=多个文件上传>多个文件上传</h3><pre><code class=language-go>func main() {
    router := gin.Default()
    // 处理multipart forms提交文件时默认的内存限制是32 MiB
    // 可以通过下面的方式修改
    // router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB
    router.POST(&quot;/upload&quot;, func(c *gin.Context) {
        // Multipart form
        form, _ := c.MultipartForm()
        files := form.File[&quot;file&quot;]
        for index, file := range files {
            log.Println(file.Filename)
            dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index)
            // 上传文件到指定的目录
            c.SaveUploadedFile(file, dst)
        }
        c.JSON(http.StatusOK, gin.H{
            &quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)),
        })
    })
    router.Run()
}
</code></pre><h2 id=gin中间件>Gin中间件</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录校验、日志打印、耗时统计等。</p><p>Gin中的中间件必须是一个gin.HandlerFunc类型。例如我们像下面的代码一样定义一个中间件。</p><pre><code class=language-go>// StatCost 是一个统计耗时请求耗时的中间件
func StatCost() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Set(&quot;name&quot;, &quot;小王子&quot;)
        // 执行其他中间件
        c.Next()
        // 计算耗时
        cost := time.S***art)
        log.Println(cost)
    }
}
</code></pre><p>然后注册中间件的时候，可以在全局注册。</p><pre><code class=language-go>func main() {
    // 新建一个没有任何默认中间件的路由
    r := gin.New()
    // 注册一个全局中间件
    r.Use(StatCost())

    r.GET(&quot;/test&quot;, func(c *gin.Context) {
        name := c.MustGet(&quot;name&quot;).(string)
        log.Println(name)
        c.JSON(http.StatusOK, gin.H{
            &quot;message&quot;: &quot;Hello world!&quot;,
        })
    })
    r.Run()
}
</code></pre><p>也可以给某个路由单独注册中间件。</p><pre><code class=language-go>// 给/test2路由单独注册中间件（可注册多个）
    r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) {
        name := c.MustGet(&quot;name&quot;).(string)
        log.Println(name)
        c.JSON(http.StatusOK, gin.H{
            &quot;message&quot;: &quot;Hello world!&quot;,
        })
    })
</code></pre><h3 id=重定向>重定向</h3><h4 id=http重定向>HTTP重定向</h4><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><pre><code class=language-go>r.GET(&quot;/test&quot;, func(c *gin.Context) {
    c.Redirect(http.StatusMovedPermanently, &quot;http://www.google.com/&quot;)
})
</code></pre><h4 id=路由重定向>路由重定向</h4><p>路由重定向，使用HandleContext：</p><pre><code class=language-go>r.GET(&quot;/test&quot;, func(c *gin.Context) {
    // 指定重定向的URL
    c.Request.URL.Path = &quot;/test2&quot;
    r.HandleContext(c)
})
r.GET(&quot;/test2&quot;, func(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;})
})
</code></pre><h2 id=gin路由>Gin路由</h2><h3 id=普通路由>普通路由</h3><pre><code class=language-go>r.GET(&quot;/index&quot;, func(c *gin.Context) {...})
r.GET(&quot;/login&quot;, func(c *gin.Context) {...})
r.POST(&quot;/login&quot;, func(c *gin.Context) {...})
</code></pre><p>此外，还有一个可以匹配所有请求方法的Any方法如下：</p><pre><code class=language-go>r.Any(&quot;/test&quot;, func(c *gin.Context) {...})
</code></pre><p>为没有配置处理函数的路由添加处理程序。默认情况下它返回404代码。</p><pre><code class=language-go>r.NoRoute(func(c *gin.Context) {
        c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil)
    })
</code></pre><h3 id=路由组>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。</p><pre><code class=language-go>func main() {
    r := gin.Default()
    userGroup := r.Group(&quot;/user&quot;)
    {
        userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})
        userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...})
        userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...})
    }
    shopGroup := r.Group(&quot;/shop&quot;)
    {
        shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})
        shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})
        shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})
    }
    r.Run()
}
</code></pre><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h3 id=路由分文件>路由分文件</h3><ol><li>在route中初始化route和切片路由组</li><li>在各个文件写路由</li><li>在main中把路由函数放入函数路由组</li></ol><pre><code class=language-go>// route中go
package route
import &quot;github.com/gin-gonic/gin&quot;
type Option func(*gin.Engine)
var options = []Option{} // 路由函数组
// 注册app的路由配置
func Include(opts ...Option) {
    options = append(options, opts...) // 路由函数组添加函数
}
// 初始化
func Init() *gin.Engine {
    r := gin.New()
    for _, function := range options {
        function(r) // 执行路由函数组中所有函数
    }
    return r
}
</code></pre><pre><code class=language-go>// shop中的文件
package shop
import &quot;github.com/gin-gonic/gin&quot;
func Routers(e *gin.Engine) {// 路由函数
    e.GET(&quot;/post&quot;, func(c *gin.Context) {
        c.String(200,&quot;psot shop&quot;)
    })
    e.GET(&quot;/comment&quot;, func(c *gin.Context) {
        c.String(200,&quot;comment shop&quot;)
    })
}
</code></pre><pre><code class=language-go>// main.go
package main
import (
    &quot;test/demo1/route&quot;
    &quot;test/demo1/shop&quot;
)
func main() {
    route.Include(shop.Routers)
    // 初始化路由
    r := route.Init() 
    _ = r.Run()
}
</code></pre><h3 id=路由原理>路由原理</h3><p>Gin框架中的路由使用的是<a href=https://github.com/julienschmidt/httprouter target=_blank>httprouter</a>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h2 id=参考文章>参考文章</h2><ul><li><a href=https://www.liwenzhou.com/posts/Go/Gin_framework/ target=_blank>https://www.liwenzhou.com/posts/Go/Gin_framework/</a></li></ul></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector('.post-comment'),t=document.body.getAttribute('data-theme');t==='auto'?t=window.matchMedia('(prefers-color-scheme: dark)').matches?'photon-dark':'github-light':t=t==='dark'?'photon-dark':'github-light',e=document.createElement('script'),e.src='https://utteranc.es/client.js',e.setAttribute('repo','haiyux/haiyux.github.io'),e.setAttribute('issue-term','pathname'),e.setAttribute('theme',t),e.setAttribute('crossorigin','anonymous'),e.setAttribute('async',''),document.querySelector('.post-comment').appendChild(e),document.querySelector('span.post-comment-notloaded').setAttribute('style','display: none;')}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=mailto:haiyux@foxmail.com target=_blank><span>Email</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#gin框架介绍>Gin框架介绍</a></li><li><a href=#gin框架安装>Gin框架安装</a></li><li><a href=#restful-api>RESTful API</a></li><li><a href=#gin渲染>Gin渲染</a><ul><li><a href=#html渲染>HTML渲染</a></li><li><a href=#静态文件处理>静态文件处理</a></li><li><a href=#补充文件路径处理>补充文件路径处理</a></li><li><a href=#json渲染>JSON渲染</a></li><li><a href=#xml渲染>XML渲染</a></li><li><a href=#ymal渲染>YMAL渲染</a></li><li><a href=#protobuf渲染>protobuf渲染</a></li></ul></li><li><a href=#获取参数>获取参数</a><ul><li><a href=#获取querystring参数>获取querystring参数</a></li><li><a href=#获取form参数>获取form参数</a></li><li><a href=#获取path参数>获取path参数</a></li><li><a href=#参数绑定>参数绑定</a></li></ul></li><li><a href=#文件上传>文件上传</a><ul><li><a href=#多个文件上传>多个文件上传</a></li></ul></li><li><a href=#gin中间件>Gin中间件</a><ul><li><a href=#重定向>重定向</a></li></ul></li><li><a href=#gin路由>Gin路由</a><ul><li><a href=#普通路由>普通路由</a></li><li><a href=#路由组>路由组</a></li><li><a href=#路由分文件>路由分文件</a></li><li><a href=#路由原理>路由原理</a></li></ul></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=mailto:haiyux@foxmail.com target=_blank><span>Email</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#gin框架介绍>Gin框架介绍</a></li><li><a href=#gin框架安装>Gin框架安装</a></li><li><a href=#restful-api>RESTful API</a></li><li><a href=#gin渲染>Gin渲染</a><ul><li><a href=#html渲染>HTML渲染</a></li><li><a href=#静态文件处理>静态文件处理</a></li><li><a href=#补充文件路径处理>补充文件路径处理</a></li><li><a href=#json渲染>JSON渲染</a></li><li><a href=#xml渲染>XML渲染</a></li><li><a href=#ymal渲染>YMAL渲染</a></li><li><a href=#protobuf渲染>protobuf渲染</a></li></ul></li><li><a href=#获取参数>获取参数</a><ul><li><a href=#获取querystring参数>获取querystring参数</a></li><li><a href=#获取form参数>获取form参数</a></li><li><a href=#获取path参数>获取path参数</a></li><li><a href=#参数绑定>参数绑定</a></li></ul></li><li><a href=#文件上传>文件上传</a><ul><li><a href=#多个文件上传>多个文件上传</a></li></ul></li><li><a href=#gin中间件>Gin中间件</a><ul><li><a href=#重定向>重定向</a></li></ul></li><li><a href=#gin路由>Gin路由</a><ul><li><a href=#普通路由>普通路由</a></li><li><a href=#路由组>路由组</a></li><li><a href=#路由分文件>路由分文件</a></li><li><a href=#路由原理>路由原理</a></li></ul></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://www.zhaohaiyu.com>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>