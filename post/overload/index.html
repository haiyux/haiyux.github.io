<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>从kratos分析BBR限流源码实现 - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta property="og:title" content="从kratos分析BBR限流源码实现"><meta name=twitter:title content="从kratos分析BBR限流源码实现"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/overload/"><meta property="og:description" content="什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达"><meta name=twitter:description content="什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2021-09-04T11:58:30+08:00"><meta property="article:modified_time" content="2021-09-04T11:58:30+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/overload/>从kratos分析BBR限流源码实现</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-09-04</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1769 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;4 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;无标签</span></div><div class="post-content markdown-body"><h2 id=什么是自适应限流>什么是自适应限流</h2><p>自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p><strong>核心目标：</strong></p><ul><li>自动嗅探负载和 qps，减少人工配置</li><li>削顶，保证超载时系统不被拖垮，并能以高水位 qps 继续运行</li></ul><h2 id=限流规则>限流规则</h2><p><img class=img-zoomable src=/images/2344773-20210904211230446-1339482393.png alt></p><p><strong>计算吞吐量：利特尔法则 <code>L = λ * W</code></strong></p><p>如上图所示，如果我们开一个小店，平均每分钟进店 2 个客人(λ)，每位客人从等待到完成交易需要 4 分钟(W)，那我们店里能承载的客人数量就是 2 * 4 = 8 个人</p><p>同理，我们可以将 <code>λ</code> 当做 QPS， <code>W</code> 呢是每个请求需要花费的时间，那我们的系统的吞吐就是 <code>L = λ * W</code> ，所以我们可以使用利特尔法则来计算系统的吞吐量。</p><h3 id=指标介绍>指标介绍</h3><table><thead><tr><th>指标名称</th><th>指标含义</th></tr></thead><tbody><tr><td>cpu</td><td>最近 1s 的 CPU 使用率均值，使用滑动平均计算，采样周期是 250ms</td></tr><tr><td>inflight</td><td>当前处理中正在处理的请求数量</td></tr><tr><td>pass</td><td>请求处理成功的量</td></tr><tr><td>rt</td><td>请求成功的响应耗时</td></tr></tbody></table><h3 id=滑动窗口>滑动窗口</h3><p>在自适应限流保护中，采集到的指标的时效性非常强，系统只需要采集最近一小段时间内的 qps、rt 即可，对于较老的数据，会自动丢弃。为了实现这个效果，kratos 使用了滑动窗口来保存采样数据。</p><p><img class=img-zoomable src=/images/2344773-20210904211301040-969014004.png alt></p><p>如上图，展示了一个具有两个桶（bucket）的滑动窗口（rolling window）。整个滑动窗口用来保存最近 1s 的采样数据，每个小的桶用来保存 500ms 的采样数据。 当时间流动之后，过期的桶会自动被新桶的数据覆盖掉，在图中，在 1000-1500ms 时，bucket 1 的数据因为过期而被丢弃，之后 bucket 3 的数据填到了窗口的头部。</p><h3 id=限流公式>限流公式</h3><p>判断是否丢弃当前请求的算法如下：</p><pre><code class=language-go>cpu &gt; 800 AND (Now - PrevDrop) &lt; 1s AND (MaxPass * MinRt * windows / 1000) &lt; InFlight
</code></pre><p>MaxPass 表示最近 5s 内，单个采样窗口中最大的请求数。 MinRt 表示最近 5s 内，单个采样窗口中最小的响应时间。 windows 表示一秒内采样窗口的数量，默认配置中是 5s 50 个采样，那么 windows 的值为 10。</p><h2 id=源码分析>源码分析</h2><h2 id=代码地址>代码地址：</h2><ul><li><a href=https://github.com/go-kratos/aegis/tree/main/ratelimit/bbr target=_blank>https://github.com/go-kratos/aegis/tree/main/ratelimit/bbr</a></li></ul><h3 id=bbr-struct>BBR struct</h3><pre><code class=language-go>type BBR struct {
    cpu             cpuGetter
    passStat        window.RollingCounter
    rtStat          window.RollingCounter
    inFlight        int64
    bucketPerSecond int64
    bucketSize      time.Duration

    // prevDropTime defines previous start drop since initTime
    prevDropTime atomic.Value
    maxPASSCache atomic.Value
    minRtCache   atomic.Value

    opts *options
}
</code></pre><ol><li><code>cpu</code><ul><li>cpu的指标函数，CPU的使用率， 这里为了减小误差，把数字扩大化，乘以1000，比赛使用率60%，也就是0.6 cpu的值就为600</li></ul></li><li><code>passStat</code><ul><li>请求数的采样数据，使用滑动窗口进行统计</li></ul></li><li><code>rtStat</code><ul><li>响应时间的采样数据，同样使用滑动窗口进行统计</li></ul></li><li><code>inFlight</code><ul><li>当前系统中的请求数，数据得来方法是：中间件原理在处理前+1，处理handle之后不管成功失败都减去1</li></ul></li><li><code>bucketPerSecond</code><ul><li>一个 bucket 的时间</li></ul></li><li><code>bucketSize</code><ul><li>桶的数量</li></ul></li><li><code>prevDropTime</code><ul><li>上次触发限流时间</li></ul></li><li><code>maxPASSCache</code><ul><li>单个采样窗口中最大的请求数的缓存数据</li></ul></li><li><code>minRtCache</code><ul><li>单个采样窗口中最小的响应时间的缓存数据</li></ul></li></ol><h2 id=allow接口>Allow接口</h2><pre><code class=language-go>// Allow checks all inbound traffic.
// Once overload is detected, it raises limit.ErrLimitExceed error.
func (l *BBR) Allow(ctx context.Context) (func(), error) {
    if l.shouldDrop() { // shouldDrop 判断是否需要限流，如果true表示拒绝 之后重点讲
        return nil, ErrLimitExceed
    }
    atomic.AddInt64(&amp;l.inFlight, 1) // 之前说的，正在处理数+1
    stime := time.Since(initTime) // 现在时间减去程序初始化时间 表示程序开始执行时刻
    return func() { // allow返回函数 在中间件（拦截器）中handle执行完成后调用
        rt := int64((time.Since(initTime) - stime) / time.Millisecond)  // 执行完handle的时间减去stime 表示 程序执行的总时间 单位ms
        l.rtStat.Add(rt) // 把处理时间放进采样数据window
        atomic.AddInt64(&amp;l.inFlight, -1) // 正在处理数-1 便是处理完成
        l.passStat.Add(1) // 成功了，把通过数的采样数据window加1
    }, nil
}
</code></pre><h3 id=shoulddrop方法>shouldDrop方法</h3><pre><code class=language-go>func (l *BBR) shouldDrop() bool {
    curTime := time.Since(initTime)
    if l.cpu() &lt; l.opts.CPUThreshold {
        // current cpu payload below the threshold
        prevDropTime, _ := l.prevDropTime.Load().(time.Duration)
        if prevDropTime == 0 {
            // haven't start drop,
            // accept current request
            return false
        }
        if curTime-prevDropTime &lt;= time.Second {
            // just start drop one second ago,
            // check current inflight count
            inFlight := atomic.LoadInt64(&amp;l.inFlight)
            return inFlight &gt; 1 &amp;&amp; inFlight &gt; l.maxInFlight()
        }
        l.prevDropTime.Store(time.Duration(0))
        return false
    }

    // current cpu payload exceeds the threshold
    inFlight := atomic.LoadInt64(&amp;l.inFlight)
    drop := inFlight &gt; 1 &amp;&amp; inFlight &gt; l.maxInFlight()
    if drop {
        prevDrop, _ := l.prevDropTime.Load().(time.Duration)
        if prevDrop != 0 {
            // already started drop, return directly
            return drop
        }
        // store start drop time
        l.prevDropTime.Store(curTime)
    }
    return drop
}
</code></pre><p><strong>maxInFlight()方法代表过去的负载</strong></p><pre><code class=language-go>int64(math.Floor(float64(l.maxPASS()*l.minRT()*l.bucketPerSecond)/1000.0) + 0.5)
</code></pre><p>参考算法：https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</p><ul><li>maxPass * bucketPerSecond / 1000 为每毫秒处理的请求数</li><li>l.minRT() 为 单个采样窗口中最小的响应时间</li><li>T ≈ QPS * Avg(RT)</li><li><code>+ 0.5</code>为向上取整</li></ul><h3 id=流程图>流程图</h3><p><img class=img-zoomable src=/images/2344773-20210904211812635-532505183.png alt></p><h2 id=压测报告>压测报告</h2><p>场景1，请求以每秒增加1个的速度不停上升，压测效果如下：</p><p><img class=img-zoomable src=/images/2344773-20210904211333316-1994244965.png alt></p><p>左测是没有限流的压测效果，右侧是带限流的压测效果。 可以看到，没有限流的场景里，系统在 700qps 时开始抖动，在 1k qps 时被拖垮，几乎没有新的请求能被放行，然而在使用限流之后，系统请求能够稳定在 600 qps 左右，rt 没有暴增，服务也没有被打垮，可见，限流有效的保护了服务。</p><p>参考文章：</p><ul><li><a href=https://v1.go-kratos.dev/#/ratelimit target=_blank>https://v1.go-kratos.dev/#/ratelimit</a></li><li><a href=https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81 target=_blank>https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></li></ul><hr><p><img class=img-zoomable src=/images/2344773-20210902225224456-315933124.png alt></p><p><img class=img-zoomable src=/images/2344773-20210902225203602-1750987546.gif alt></p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","haiyux/haiyux.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#什么是自适应限流>什么是自适应限流</a></li><li><a href=#限流规则>限流规则</a><ul><li><a href=#指标介绍>指标介绍</a></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#限流公式>限流公式</a></li></ul></li><li><a href=#源码分析>源码分析</a></li><li><a href=#代码地址>代码地址：</a><ul><li><a href=#bbr-struct>BBR struct</a></li></ul></li><li><a href=#allow接口>Allow接口</a><ul><li><a href=#shoulddrop方法>shouldDrop方法</a></li><li><a href=#流程图>流程图</a></li></ul></li><li><a href=#压测报告>压测报告</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#什么是自适应限流>什么是自适应限流</a></li><li><a href=#限流规则>限流规则</a><ul><li><a href=#指标介绍>指标介绍</a></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#限流公式>限流公式</a></li></ul></li><li><a href=#源码分析>源码分析</a></li><li><a href=#代码地址>代码地址：</a><ul><li><a href=#bbr-struct>BBR struct</a></li></ul></li><li><a href=#allow接口>Allow接口</a><ul><li><a href=#shoulddrop方法>shouldDrop方法</a></li><li><a href=#流程图>流程图</a></li></ul></li><li><a href=#压测报告>压测报告</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://github.com/haiyux/haiyux.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>