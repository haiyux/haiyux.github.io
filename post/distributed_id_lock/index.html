<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>分布式ID和锁 - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta name=keywords content="微服务"><meta property="og:title" content="分布式ID和锁"><meta name=twitter:title content="分布式ID和锁"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/distributed_id_lock/"><meta property="og:description" content="分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。明星"><meta name=twitter:description content="分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。明星"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2021-01-23T15:13:11+08:00"><meta property="article:modified_time" content="2021-01-23T15:13:11+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/distributed_id_lock/>分布式ID和锁</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-01-23</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3699 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;8 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1>微服务</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=分布式id生成器>分布式id生成器</h2><p>有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。明星出轨时，会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。</p><p>在插入数据库之前，我们需要给这些消息、订单先打上一个ID，然后再插入到我们的数据库。对这个id的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序。</p><p><em>Twitter的snowflake算法是这种场景下的一个典型解法。先来看看snowflake是怎么一回事</em>：</p><p><img class=img-zoomable src=/images/2344773-20210821154455384-787668998.png alt></p><p><em>snowflake中的比特位分布</em></p><p>首先确定我们的数值是64位，int64类型，被划分为四部分，不含开头的第一个bit，因为这个bit是符号位。用41位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的id，然后再五位来表示机器的实例id，最后是12位的循环自增id（到达1111,1111,1111后会归0）。</p><p>这样的机制可以支持我们在同一台机器上，同一毫秒内产生<code>2 ^ 12 = 4096</code>条消息。一秒共409.6万条消息。从值域上来讲完全够用了。</p><p>数据中心加上实例id共有10位，可以支持我们每数据中心部署32台机器，所有数据中心共1024台实例。</p><p>表示<code>timestamp</code>的41位，可以支持我们使用69年。当然，我们的时间毫秒计数不会真的从1970年开始记，那样我们的系统跑到<code>2039/9/7 23:47:35</code>就不能用了，所以这里的<code>timestamp</code>实际上只是相对于某个时间的增量，比如我们的系统上线是2018-08-01，那么我们可以把这个timestamp当作是从<code>2018-08-01 00:00:00.000</code>的偏移量。</p><h3 id=worker_id分配>worker_id分配</h3><p><code>timestamp</code>，<code>datacenter_id</code>，<code>worker_id</code>和<code>sequence_id</code>这四个字段中，<code>timestamp</code>和<code>sequence_id</code>是由程序在运行期生成的。但<code>datacenter_id</code>和<code>worker_id</code>需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的id有冲突）。</p><p>一般不同数据中心的机器，会提供对应的获取数据中心id的API，所以<code>datacenter_id</code>我们可以在部署阶段轻松地获取到。而worker_id是我们逻辑上给机器分配的一个id，这个要怎么办呢？比较简单的想法是由能够提供这种自增id功能的工具来支持，比如MySQL:</p><pre><code class=language-shell>mysql&gt; insert into a (ip) values(&quot;10.1.2.101&quot;);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select last_insert_id();
+------------------+
| last_insert_id() |
+------------------+
|                2 |
+------------------+
1 row in set (0.00 sec)
</code></pre><p>从MySQL中获取到<code>worker_id</code>之后，就把这个<code>worker_id</code>直接持久化到本地，以避免每次上线时都需要获取新的<code>worker_id</code>。让单实例的<code>worker_id</code>可以始终保持不变。</p><p>当然，使用MySQL相当于给我们简单的id生成服务增加了一个外部依赖。依赖越多，我们的服务的可运维性就越差。</p><p>考虑到集群中即使有单个id生成服务的实例挂了，也就是损失一段时间的一部分id，所以我们也可以更简单暴力一些，把<code>worker_id</code>直接写在worker的配置中，上线时，由部署脚本完成<code>worker_id</code>字段替换。</p><h3 id=开源实例>开源实例</h3><h4 id=标准snowflake实现>标准snowflake实现</h4><p><code>github.com/bwmarrin/snowflake</code> 是一个相当轻量化的snowflake的Go实现。其文档对各位使用的定义见<em>图 6-2</em>所示。</p><p><img class=img-zoomable src=/images/2344773-20210821154507976-124951092.png alt></p><p><em>图 6-2 snowflake库</em></p><p>和标准的snowflake完全一致。使用上比较简单：</p><pre><code class=language-go>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/bwmarrin/snowflake&quot;
)

func main() {
    n, err := snowflake.NewNode(1)
    if err != nil {
        println(err)
        os.Exit(1)
    }

    for i := 0; i &lt; 3; i++ {
        id := n.Generate()
        fmt.Println(&quot;id&quot;, id)
        fmt.Println(
            &quot;node: &quot;, id.Node(),
            &quot;step: &quot;, id.Step(),
            &quot;time: &quot;, id.Time(),
            &quot;\n&quot;,
        )
    }
}
</code></pre><p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p><pre><code class=language-go>    // Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC
    // You may customize this to set a different epoch for your application.
    Epoch int64 = 1288834974657

    // Number of bits to use for Node
    // Remember, you have a total 22 bits to share between Node/Step
    NodeBits uint8 = 10

    // Number of bits to use for Step
    // Remember, you have a total 22 bits to share between Node/Step
    StepBits uint8 = 12
</code></pre><p><code>Epoch</code>就是本节开头讲的起始时间，<code>NodeBits</code>指的是机器编号的位长，<code>StepBits</code>指的是自增序列的位长。</p><h4 id=sonyflake>sonyflake</h4><p>sonyflake是Sony公司的一个开源项目，基本思路和snowflake差不多，不过位分配上稍有不同，见<em>图 6-3</em>：</p><p><img class=img-zoomable src=/images/2344773-20210821154526488-1644768550.png alt></p><p><em>图 6-3 sonyflake</em></p><p>这里的时间只用了39个bit，但时间的单位变成了10ms，所以理论上比41位表示的时间还要久(174年)。</p><p><code>Sequence ID</code>和之前的定义一致，<code>Machine ID</code>其实就是节点id。<code>sonyflake</code>与众不同的地方在于其在启动阶段的配置参数：</p><pre><code class=language-go>func NewSonyflake(st Settings) *Sonyflake
</code></pre><p><code>Settings</code>数据结构如下：</p><pre><code class=language-go>type Settings struct {
    StartTime      time.Time
    MachineID      func() (uint16, error)
    CheckMachineID func(uint16) bool
}
</code></pre><p><code>StartTime</code>选项和我们之前的<code>Epoch</code>差不多，如果不设置的话，默认是从<code>2014-09-01 00:00:00 +0000 UTC</code>开始。</p><p><code>MachineID</code>可以由用户自定义的函数，如果用户不定义的话，会默认将本机IP的低16位作为<code>machine id</code>。</p><p><code>CheckMachineID</code>是由用户提供的检查<code>MachineID</code>是否冲突的函数。这里的设计还是比较巧妙的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查<code>MachineID</code>是否冲突的逻辑。如果公司有现成的Redis集群，那么我们可以很轻松地用Redis的集合类型来检查冲突。</p><pre><code class=language-shell>redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=
(integer) 1
redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=
(integer) 0
</code></pre><p>使用起来也比较简单，有一些逻辑简单的函数就略去实现了：</p><pre><code class=language-go>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;time&quot;

    &quot;github.com/sony/sonyflake&quot;
)

func getMachineID() (uint16, error) {
    var machineID uint16
    var err error
    machineID = readMachineIDFromLocalFile()
    if machineID == 0 {
        machineID, err = generateMachineID()
        if err != nil {
            return 0, err
        }
    }

    return machineID, nil
}

func checkMachineID(machineID uint16) bool {
    saddResult, err := saddMachineIDToRedisSet()
    if err != nil || saddResult == 0 {
        return true
    }

    err := saveMachineIDToLocalFile(machineID)
    if err != nil {
        return true
    }

    return false
}

func main() {
    t, _ := time.Parse(&quot;2006-01-02&quot;, &quot;2018-01-01&quot;)
    settings := sonyflake.Settings{
        StartTime:      t,
        MachineID:      getMachineID,
        CheckMachineID: checkMachineID,
    }

    sf := sonyflake.NewSonyflake(settings)
    id, err := sf.NextID()
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }

    fmt.Println(id)
}
</code></pre><h2 id=分布式锁>分布式锁</h2><p>在单机程序并发或并行修改全局变量时，需要对修改行为加锁以创造临界区。为什么需要加锁呢？我们看看在不加锁的情况下并发计数会发生什么情况：</p><pre><code class=language-go>package main

import (
    &quot;sync&quot;
)

// 全局变量
var counter int

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go func() {
        defer wg.Done()
            counter++
        }()
    }

    wg.Wait()
    println(counter)
}
</code></pre><p>多次运行会得到不同的结果：</p><pre><code class=language-shell>❯❯❯ go run local_lock.go
945
❯❯❯ go run local_lock.go
937
❯❯❯ go run local_lock.go
959
</code></pre><h3 id=基于redis的setnx>基于Redis的setnx</h3><p>在分布式场景下，我们也需要这种“抢占”的逻辑，这时候怎么办呢？我们可以使用Redis提供的<code>setnx</code>命令：</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;

	&quot;github.com/go-redis/redis&quot;
	&quot;github.com/gofrs/uuid&quot;
)

// 声明一个全局的rdb变量
var rdb *redis.Client

// 初始化连接
func initClient() (err error) {
	rdb = redis.NewClient(&amp;redis.Options{
		Addr:     &quot;localhost:6379&quot;,
		Password: &quot;zhy1996&quot;, // no password set
		DB:       0,         // use default DB
	})

	_, err = rdb.Ping().Result()
	if err != nil {
		return err
	}
	return nil
}

var unlock_lua = `
if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
	return redis.call(&quot;del&quot;,KEYS[1])
else
	return 0
end
`

func Lock(key, value string, expiration time.Duration) (bool, error) {
	is, err := rdb.SetNX(key, value, expiration).Result()
	if err != nil {
		return false, fmt.Errorf(&quot;redis setnx failed&quot;)
	}
	return is, nil
}

func UnLock(key, value string) (bool, error) {
	res, err := rdb.Eval(unlock_lua, []string{key}, value).Result()
	if err != nil {
		return false, err
	}
	v, ok := res.(int64)
	if !ok {
		return false, fmt.Errorf(&quot;lua script return is not int&quot;)
	}
	if v == 0 {
		return false, nil
	}
	return true, nil
}

func main() {
	err := initClient()
	if err != nil {
		fmt.Println(err)
	}

	ul, _ := uuid.NewV4()
	value := ul.String()

	for i := 0; i &lt; 10; i++ {
		is, err := Lock(&quot;lock_1&quot;, value, time.Second)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println(&quot;是否拿到锁:&quot;, is)
	}

	res, err := UnLock(&quot;lock_1&quot;, value)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(&quot;解锁:&quot;, res)
}
</code></pre><p>看看运行结果：</p><pre><code class=language-shell>是否拿到锁: true
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
是否拿到锁: false
解锁: true
</code></pre><p>通过代码和执行结果可以看到，我们远程调用<code>setnx</code>实际上和单机的trylock非常相似，如果获取锁失败，那么相关的任务逻辑就不应该继续向前执行。</p><p><code>setnx</code>很适合在高并发场景下，用来争抢一些“唯一”的资源。比如交易撮合系统中卖家发起订单，而多个买家会对其进行并发争抢。这种场景我们没有办法依赖具体的时间来判断先后，因为不管是用户设备的时间，还是分布式场景下的各台机器的时间，都是没有办法在合并后保证正确的时序的。哪怕是我们同一个机房的集群，不同的机器的系统时间可能也会有细微的差别。</p><p>所以，我们需要依赖于这些请求到达Redis节点的顺序来做正确的抢锁操作。如果用户的网络环境比较差，那也只能自求多福了。</p><h3 id=基于etcd>基于etcd</h3><p>etcd是分布式系统中，功能上与ZooKeeper类似的组件，这两年越来越火了。上面基于ZooKeeper我们实现了分布式阻塞锁，基于etcd，也可以实现类似的功能：</p><pre><code class=language-go>package main

import (
    &quot;log&quot;

    &quot;github.com/zieckey/etcdsync&quot;
)

func main() {
    m, err := etcdsync.New(&quot;/lock&quot;, 10, []string{&quot;http://127.0.0.1:2379&quot;})
    if m == nil || err != nil {
        log.Printf(&quot;etcdsync.New failed&quot;)
        return
    }
    err = m.Lock()
    if err != nil {
        log.Printf(&quot;etcdsync.Lock failed&quot;)
        return
    }

    log.Printf(&quot;etcdsync.Lock OK&quot;)
    log.Printf(&quot;Get the lock. Do something here.&quot;)

    err = m.Unlock()
    if err != nil {
        log.Printf(&quot;etcdsync.Unlock failed&quot;)
    } else {
        log.Printf(&quot;etcdsync.Unlock OK&quot;)
    }
}
</code></pre><p>etcd中没有像ZooKeeper那样的Sequence节点。所以其锁实现和基于ZooKeeper实现的有所不同。在上述示例代码中使用的etcdsync的Lock流程是：</p><ol><li>先检查<code>/lock</code>路径下是否有值，如果有值，说明锁已经被别人抢了</li><li>如果没有值，那么写入自己的值。写入成功返回，说明加锁成功。写入时如果节点被其它节点写入过了，那么会导致加锁失败，这时候到 3</li><li>watch <code>/lock</code>下的事件，此时陷入阻塞</li><li>当<code>/lock</code>路径下发生事件时，当前进程被唤醒。检查发生的事件是否是删除事件（说明锁被持有者主动unlock），或者过期事件（说明锁过期失效）。如果是的话，那么回到 1，走抢锁流程。</li></ol><p>值得一提的是，在etcdv3的API中官方已经提供了可以直接使用的锁API，读者可以查阅etcd的文档做进一步的学习。</p><p>参考文章：《go语言高级编程》</p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","haiyux/haiyux.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#分布式id生成器>分布式id生成器</a><ul><li><a href=#worker_id分配>worker_id分配</a></li><li><a href=#开源实例>开源实例</a></li></ul></li><li><a href=#分布式锁>分布式锁</a><ul><li><a href=#基于redis的setnx>基于Redis的setnx</a></li><li><a href=#基于etcd>基于etcd</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#分布式id生成器>分布式id生成器</a><ul><li><a href=#worker_id分配>worker_id分配</a></li><li><a href=#开源实例>开源实例</a></li></ul></li><li><a href=#分布式锁>分布式锁</a><ul><li><a href=#基于redis的setnx>基于Redis的setnx</a></li><li><a href=#基于etcd>基于etcd</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://github.com/haiyux/haiyux.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>