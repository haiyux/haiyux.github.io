<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.101.0"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Nethttp Gin - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta name=keywords content="golang,http"><meta property="og:title" content="Nethttp Gin"><meta name=twitter:title content="Nethttp Gin"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/nethttp-gin/"><meta property="og:description" content="net/http 路由注册 func test1() { http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &#34;Hello world!&#34;) }) err := http.ListenAndServe(&#34;:9001&#34;, nil) if err != nil { log.Fatal(&#34;ListenAndServer:&#34;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li"><meta name=twitter:description content="net/http 路由注册 func test1() { http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &#34;Hello world!&#34;) }) err := http.ListenAndServe(&#34;:9001&#34;, nil) if err != nil { log.Fatal(&#34;ListenAndServer:&#34;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2021-12-16T22:09:38+08:00"><meta property="article:modified_time" content="2021-12-16T22:09:38+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/nethttp-gin/>Nethttp Gin</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-12-16</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;4116 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;9 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/golang>golang</a>&nbsp;<a href=/tags/http>http</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=nethttp-路由注册>net/http 路由注册</h2><pre><code class=language-go>func test1() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &quot;Hello world!&quot;)
    })
    err := http.ListenAndServe(&quot;:9001&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServer:&quot;, err)
    }
}
</code></pre><p>在使用<code>ListenAndServe</code>这个方法时，系统就会给我们指派一个路由器，<code>DefaultServeMux</code>是系统默认使用的路由器，如果<code>ListenAndServe</code>这个方法的第2个参数传入nil，系统就会默认使用<code>DefaultServeMux</code>。当然，这里也可以传入自定义的路由器。</p><p>先看<code>http.HandleFunc("/", ...)</code>，从<code>HandleFunc</code>方法点进去，如下：</p><pre><code class=language-go>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre><p>在这里调用了<code>DefaultServeMux</code>的<code>HandleFunc</code>方法，这个方法有两个参数，<code>pattern</code>是匹配的路由规则，<code>handler</code>表示这个路由规则对应的处理方法，并且这个处理方法有两个参数。</p><p>在我们书写的代码示例中，<code>pattern</code>对应<code>/</code>，<code>handler</code>对应<code>sayHello</code>，当我们在浏览器中输入<code>http://localhost:9001</code>时，就会触发匿名函数。</p><p>我们再顺着<code>DefaultServeMux</code>的<code>HandleFunc</code>方法继续点下去，如下：</p><pre><code class=language-go>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre><p>在这个方法中，路由器又调用了<code>Handle</code>方法，注意这个<code>Handle</code>方法的第2个参数，将之前传入的<code>handler</code>这个响应方法强制转换成了<code>HandlerFunc</code>类型。</p><p>这个<code>HandlerFunc</code>类型到底是个什么呢？如下：</p><pre><code class=language-go>type HandlerFunc func(ResponseWriter, *Request)
</code></pre><p>看来和我们定义的"/&ldquo;的匿名函数的类型都差不多。但是！！！ 这个<code>HandlerFunc</code>默认实现了<code>ServeHTTP</code>接口！这样<code>HandlerFunc</code>对象就有了<code>ServeHTTP</code>方法！如下：</p><pre><code class=language-go>// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre><p>接下来，我们返回去继续看<code>mux</code>的<code>Handle</code>方法，也就是这段代码<code>mux.Handle(pattern, HandlerFunc(handler))</code>。这段代码做了哪些事呢？源码如下</p><pre><code class=language-go>// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()

    if pattern == &quot;&quot; {
        panic(&quot;http: invalid pattern&quot;)
    }
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    if _, exist := mux.m[pattern]; exist {
        panic(&quot;http: multiple registrations for &quot; + pattern)
    }

    if mux.m == nil {
        mux.m = make(map[string]muxEntry)
    }
    e := muxEntry{h: handler, pattern: pattern}
    mux.m[pattern] = e
    if pattern[len(pattern)-1] == '/' {
        mux.es = appendSorted(mux.es, e)
    }

    if pattern[0] != '/' {
        mux.hosts = true
    }
}
</code></pre><p>主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。</p><p><code>map[string]muxEntry</code>是个什么鬼？</p><ul><li><p><code>map</code>是一个字典对象，它保存的是<code>key-value</code>。</p></li><li><p><code>[string]</code>表示这个字典的<code>key</code>是<code>string</code>类型的，这个<code>key</code>值会保存我们的路由规则。</p></li><li><p><code>muxEntry</code>是一个实例对象，这个对象内保存了路由规则对应的处理方法。</p></li><li><p><code>mux.es</code> 为模糊匹配 有长倒短排序 比如有路由<code>/hello/</code> 访问<code>/hello/world</code> 时没有路由 会落到<code>/hello/</code>上</p></li></ul><p>找到相应代码，如下：</p><pre><code class=language-go>// 路由器
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    es    []muxEntry // slice of entries sorted from longest to shortest.
    hosts bool       // whether any patterns contain hostnames
}

type muxEntry struct {
    h       Handler
    pattern string
}

// 路由响应方法
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</code></pre><h2 id=nethttp-运行>net/http 运行</h2><p>第二部分主要就是研究这句代码<code>err := http.ListenAndServe(":9001",nil)</code>，也就是<code>ListenAndServe</code>这个方法。从这个方法点进去，如下：</p><pre><code class=language-go>func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
</code></pre><p>在这个方法中，初始化了一个<code>server</code>对象，然后调用这个<code>server</code>对象的<code>ListenAndServe</code>方法，在这个方法中，如下：</p><pre><code class=language-go>func (srv *Server) ListenAndServe() error {
    if srv.shuttingDown() {
        return ErrServerClosed
    }
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(ln)
}
</code></pre><p>在这个方法中，调用了<code>net.Listen("tcp", addr)</code>，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。</p><p>代码的最后，调用了<code>srv</code>的<code>Serve</code>方法，如下：</p><pre><code class=language-go>func (srv *Server) Serve(l net.Listener) error {
    if fn := testHookServerServe; fn != nil {
        fn(srv, l) // call hook with unwrapped listener
    }

    origListener := l
    l = &amp;onceCloseListener{Listener: l}
    defer l.Close()

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    if !srv.trackListener(&amp;l, true) {
        return ErrServerClosed
    }
    defer srv.trackListener(&amp;l, false)

    baseCtx := context.Background()
    if srv.BaseContext != nil {
        baseCtx = srv.BaseContext(origListener)
        if baseCtx == nil {
            panic(&quot;BaseContext returned a nil context&quot;)
        }
    }

    var tempDelay time.Duration // how long to sleep on accept failure

    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    for {
        rw, err := l.Accept()
        if err != nil {
            select {
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, err, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return err
        }
        connCtx := ctx
        if cc := srv.ConnContext; cc != nil {
            connCtx = cc(connCtx, rw)
            if connCtx == nil {
                panic(&quot;ConnContext returned nil&quot;)
            }
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew, runHooks) // before Serve can return
        go c.serve(connCtx)
    }
}
</code></pre><p>最后3段代码比较重要，也是Go语言支持高并发的体现，如下：</p><pre><code class=language-go>c := srv.newConn(rw)
c.setState(c.rwc, StateNew, runHooks) // before Serve can return
go c.serve(connCtx)
</code></pre><p>上面那一大坨代码，总体意思是进入方法后，首先开了一个<code>for</code>循环，在<code>for</code>循环内时刻Accept请求，请求来了之后，会为每个请求创建一个<code>Conn</code>，然后单独开启一个<code>goroutine</code>，把这个请求的数据当做参数扔给这个<code>Conn</code>去服务：<code>go c.serve()</code>。用户的每一次请求都是在一个新的<code>goroutine</code>去服务，每个请求间相互不影响。</p><p>在<code>conn</code>的<code>serve</code>方法中，有一句代码很重要，如下：</p><pre><code class=language-go>serverHandler{c.server}.ServeHTTP(w, w.req)
</code></pre><p>表示<code>serverHandler</code>也实现了<code>ServeHTTP</code>接口，<code>ServeHTTP</code>方法实现如下：</p><pre><code class=language-go>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;&amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }

    if req.URL != nil &amp;&amp; strings.Contains(req.URL.RawQuery, &quot;;&quot;) {
        var allowQuerySemicolonsInUse int32
        req = req.WithContext(context.WithValue(req.Context(), silenceSemWarnContextKey, func() {
            atomic.StoreInt32(&amp;allowQuerySemicolonsInUse, 1)
        }))
        defer func() {
            if atomic.LoadInt32(&amp;allowQuerySemicolonsInUse) == 0 {
                sh.srv.logf(&quot;http: URL query contains semicolon, which is no longer a supported separator; parts of the query may be stripped when parsed; see golang.org/issue/25192&quot;)
            }
        }()
    }

    handler.ServeHTTP(rw, req)
}
</code></pre><p>在这里如果<code>handler</code>为空（这个<code>handler</code>就可以理解为是我们自定义的路由器），就会使用系统默认的<code>DefaultServeMux</code>，代码的最后调用了<code>DefaultServeMux</code>的<code>ServeHTTP()</code></p><pre><code class=language-go>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    if r.RequestURI == &quot;*&quot; {
        if r.ProtoAtLeast(1, 1) {
            w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
        }
        w.WriteHeader(StatusBadRequest)
        return
    }
    h, _ := mux.Handler(r)  //这里返回的h是Handler接口对象
    h.ServeHTTP(w, r)  //调用Handler接口对象的ServeHTTP方法实际上就调用了我们定义的sayHello方法
}
</code></pre><pre><code class=language-go>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {

    // CONNECT requests are not canonicalized.
    if r.Method == &quot;CONNECT&quot; {
        // If r.URL.Path is /tree and its handler is not registered,
        // the /tree -&gt; /tree/ redirect applies to CONNECT requests
        // but the path canonicalization does not.
        if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {
            return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
        }

        return mux.handler(r.Host, r.URL.Path)
    }

    // All other requests have any port stripped and path cleaned
    // before passing to mux.handler.
    host := stripHostPort(r.Host)
    path := cleanPath(r.URL.Path)

    // If the given path is /tree and its handler is not registered,
    // redirect for /tree/.
    if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {
        return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
    }

    if path != r.URL.Path {
        _, pattern = mux.handler(host, path)
        u := &amp;url.URL{Path: path, RawQuery: r.URL.RawQuery}
        return RedirectHandler(u.String(), StatusMovedPermanently), pattern
    }

    return mux.handler(host, r.URL.Path)
}


func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &quot;&quot;
    }
    return
}

func (mux *ServeMux) match(path string) (h Handler, pattern string) {
    // Check for exact match first.
    v, ok := mux.m[path]
    if ok {
        return v.h, v.pattern
    }

    // Check for longest valid match.  mux.es contains all patterns
    // that end in / sorted from longest to shortest.
    for _, e := range mux.es {
        if strings.HasPrefix(path, e.pattern) {
            return e.h, e.pattern
        }
    }
    return nil, &quot;&quot;
}
</code></pre><p>它会根据用户请求的<code>URL</code>到路由器里面存储的<code>map</code>中匹配，匹配成功就会返回存储的<code>handler</code>，调用这个<code>handler</code>的<code>ServeHTTP()</code>就可以执行到相应的处理方法了，这个处理方法实际上就是我们刚开始定义的<code>sayHello()</code>，只不过这个<code>sayHello()</code>被<code>HandlerFunc</code>又包了一层，因为<code>HandlerFunc</code>实现了<code>ServeHTTP</code>接口，所以在调用<code>HandlerFunc</code>对象的<code>ServeHTTP()</code>时，实际上在<code>ServeHTTP ()</code>的内部调用了我们的<code>sayHello()</code>。</p><h2 id=总结>总结</h2><ol><li>调用<code>http.ListenAndServe(":9090",nil)</code></li><li>实例化<code>server</code></li><li>调用<code>server</code>的<code>ListenAndServe()</code></li><li>调用<code>server</code>的<code>Serve</code>方法，开启<code>for</code>循环，在循环中Accept请求</li><li>对每一个请求实例化一个<code>Conn</code>，并且开启一个<code>goroutine</code>为这个请求进行服务<code>go c.serve()</code></li><li>读取每个请求的内容<code>c.readRequest()</code></li><li>调用<code>serverHandler</code>的<code>ServeHTTP()</code>，如果<code>handler</code>为空，就把<code>handler</code>设置为系统默认的路由器<code>DefaultServeMux</code></li><li>调用<code>handler</code>的<code>ServeHTTP()</code> =>实际上是调用了<code>DefaultServeMux</code>的<code>ServeHTTP()</code></li><li>在<code>ServeHTTP()</code>中会调用路由对应处理<code>handler</code></li><li>在路由对应处理<code>handler</code>中会执行<code>sayHello()</code></li></ol><p>有一个需要注意的点： <code>DefaultServeMux</code>和路由对应的处理方法<code>handler</code>都实现了<code>ServeHTTP</code>接口，他们俩都有<code>ServeHTTP</code>方法，但是方法要达到的目的不同，在<code>DefaultServeMux</code>的<code>ServeHttp()</code>里会执行路由对应的处理<code>handler</code>的<code>ServeHttp()</code>。</p><h2 id=自定义个简单的路由>自定义个简单的路由</h2><pre><code class=language-go>package mux

import (
    &quot;net/http&quot;
    &quot;strings&quot;
)

type muxEntry struct {
    h TesthandleFunc
}

type TesthandleFunc func(http.ResponseWriter, *http.Request)

type TestHandler struct {
    routes map[string]map[string]muxEntry
}


func (h *TestHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    method := strings.ToUpper(r.Method)
    path := r.URL.Path
    if route, ok := h.routes[method]; ok {
        if entry, ok := route[path]; ok {
            entry.h(w, r)
            return
        }
    }
    w.WriteHeader(http.StatusNotFound)
}

func Newhandler() *TestHandler {
    return &amp;TestHandler{routes: make(map[string]map[string]muxEntry)}
}

func (h *TestHandler) Handle(method, path string, handler TesthandleFunc) {
    method = strings.ToUpper(method)
    if _, ok := h.routes[method]; !ok {
        h.routes[method] = make(map[string]muxEntry)
    }
    h.routes[method][path] = muxEntry{handler}
}
</code></pre><pre><code class=language-go>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;study/mux&quot;
)

func main() {
    handler := mux.Newhandler()
    handler.Handle(&quot;GET&quot;, &quot;/hello&quot;, func(rw http.ResponseWriter, r *http.Request) {
        rw.Write([]byte(&quot;Hello World&quot;))
    })
    handler.Handle(&quot;Post&quot;, &quot;/hello/world&quot;, func(rw http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(rw, &quot;你好&quot;)
    })
    http.ListenAndServe(&quot;:9002&quot;, handler)
}
</code></pre><p>自定义context</p><pre><code class=language-go>package router

import (
    &quot;encoding/json&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
)

type Context struct {
    w http.ResponseWriter
    r *http.Request
}

func (c *Context) Json(code int, v interface{}) {
    c.w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    c.w.WriteHeader(code)
    s, _ := json.Marshal(v)
    c.w.Write(s)
}

type Routerfunc func(c *Context)

type RouterHandler struct {
    routes map[string]map[string]Routerfunc
}

func NewRouterHandler() *RouterHandler {
    return &amp;RouterHandler{routes: make(map[string]map[string]Routerfunc)}
}

func (h *RouterHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    method := strings.ToUpper(r.Method)
    path := r.URL.Path
    c := &amp;Context{w: w, r: r}
    if route, ok := h.routes[method]; ok {
        if h, ok := route[path]; ok {
            h(c)
            return
        }
    }
    w.WriteHeader(http.StatusNotFound)
}

func (h *RouterHandler) Handle(method, path string, handler Routerfunc) {
    method = strings.ToUpper(method)
    if _, ok := h.routes[method]; !ok {
        h.routes[method] = make(map[string]Routerfunc)
    }
    h.routes[method][path] = handler
}

func (r *RouterHandler) Run(addr string) error {
    return http.ListenAndServe(addr, r)
}
</code></pre><h2 id=gin>Gin</h2><pre><code class=language-go>type Engine struct {
    RouterGroup

    pool     sync.Pool
    trees    methodTrees
}// trie

type RouterGroup struct {
    basePath string
    engine   *Engine
}

func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    c := engine.pool.Get().(*Context) // 从pool 拿出一个context
    c.writermem.reset(w) // 记录http.ResponseWriter 及 *http.Request
    c.Request = req
    c.reset() // 重置上一个留下的值

    engine.handleHTTPRequest(c)

    engine.pool.Put(c) // 把用完的context放回池子
}
// get: /bac
</code></pre><p><img class=img-zoomable src=/images/6c261f0b5937d728d3763beaf08f85eea6999091.png alt=5BD3C0FE-8543-42AE-AA05-D60B7A249A09.png></p><p>添加路由</p><pre><code class=language-go>func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
    absolutePath := group.calculateAbsolutePath(relativePath)
    handlers = group.combineHandlers(handlers)
    group.engine.addRoute(httpMethod, absolutePath, handlers)
    return group.returnObj()
}
</code></pre><p>Context</p><pre><code class=language-go>type Context struct {
    Request   *http.Request
    Writer    ResponseWriter

    Params   Params
    handlers HandlersChain
    index    int8
    fullPath string

    engine       *Engine
    params       *Params
    skippedNodes *[]skippedNode

    // This mutex protect Keys map
    mu sync.RWMutex

    // Keys is a key/value pair exclusively for the context of each request.
    Keys map[string]interface{}

    // Errors is a list of errors attached to all the handlers/middlewares who used this context.
    Errors errorMsgs

    // Accepted defines a list of manually accepted formats for content negotiation.
    Accepted []string

    // queryCache use url.ParseQuery cached the param query result from c.Request.URL.Query()
    queryCache url.Values

    // formCache use url.ParseQuery cached PostForm contains the parsed form data from POST, PATCH,
    // or PUT body parameters.
    formCache url.Values

    // SameSite allows a server to define a cookie attribute making it impossible for
    // the browser to send this cookie along with cross-site requests.
    sameSite http.SameSite
}

func (c *Context) Next() {
    c.index++
    for c.index &lt; int8(len(c.handlers)) {
        c.handlers[c.index](c)
        c.index++
    }
}
</code></pre><pre><code class=language-go>func (engine *Engine) handleHTTPRequest(c *Context) {
    httpMethod := c.Request.Method
    rPath := c.Request.URL.Path
    unescape := false
    if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 {
        rPath = c.Request.URL.RawPath
        unescape = engine.UnescapePathValues
    }

    if engine.RemoveExtraSlash {
        rPath = cleanPath(rPath)
    }

    // Find root of the tree for the given HTTP method
    t := engine.trees
    for i, tl := 0, len(t); i &lt; tl; i++ {
        if t[i].method != httpMethod {
            continue
        }
        root := t[i].root
        // Find route in tree
        value := root.getValue(rPath, c.params, c.skippedNodes, unescape)
        if value.params != nil {
            c.Params = *value.params
        }
        if value.handlers != nil {
            c.handlers = value.handlers
            c.fullPath = value.fullPath
            c.Next()
            c.writermem.WriteHeaderNow()
            return
        }
        if httpMethod != http.MethodConnect &amp;&amp; rPath != &quot;/&quot; {
            if value.tsr &amp;&amp; engine.RedirectTrailingSlash {
                redirectTrailingSlash(c)
                return
            }
            if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) {
                return
            }
        }
        break
    }

    if engine.HandleMethodNotAllowed {
        for _, tree := range engine.trees {
            if tree.method == httpMethod {
                continue
            }
            if value := tree.root.getValue(rPath, nil, c.skippedNodes, unescape); value.handlers != nil {
                c.handlers = engine.allNoMethod
                serveError(c, http.StatusMethodNotAllowed, default405Body)
                return
            }
        }
    }
    c.handlers = engine.allNoRoute
    serveError(c, http.StatusNotFound, default404Body)
}
</code></pre></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","haiyux/haiyux.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#nethttp-路由注册>net/http 路由注册</a></li><li><a href=#nethttp-运行>net/http 运行</a></li><li><a href=#总结>总结</a></li><li><a href=#自定义个简单的路由>自定义个简单的路由</a></li><li><a href=#gin>Gin</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#nethttp-路由注册>net/http 路由注册</a></li><li><a href=#nethttp-运行>net/http 运行</a></li><li><a href=#总结>总结</a></li><li><a href=#自定义个简单的路由>自定义个简单的路由</a></li><li><a href=#gin>Gin</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://github.com/haiyux/haiyux.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>