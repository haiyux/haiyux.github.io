<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 赵海宇的博客</title><link>https://www.zhaohaiyu.com/post/</link><description>Recent content in Posts on 赵海宇的博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 04 Jun 2022 17:03:53 +0800</lastBuildDate><atom:link href="https://www.zhaohaiyu.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>行为模式</title><link>https://www.zhaohaiyu.com/post/behavioral/</link><pubDate>Sat, 04 Jun 2022 17:03:53 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/behavioral/</guid><description>责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如 kratos,gin等开源库的中间件实现。 代码实现</description></item><item><title>结构型模式</title><link>https://www.zhaohaiyu.com/post/structure/</link><pubDate>Wed, 27 Apr 2022 15:04:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/structure/</guid><description>适配器模式 适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对json字符串进行分析等，现在有一些yaml文件也要分析，这时候我我们就应该给yaml字符串就个适配器，转换成json字符串，</description></item><item><title>创建者模式</title><link>https://www.zhaohaiyu.com/post/creator/</link><pubDate>Sat, 23 Apr 2022 16:28:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/creator/</guid><description>单例模式 为什么要用单例模式 保证一个对象只有一个实例 ，减少内存开销。比如一些可以复用一个连接的网络，比如http2 client等，而且可以减少网络开销。 为什么不用个全局变量控制 因为任何代码都有可能覆盖掉</description></item><item><title>Go错误处理</title><link>https://www.zhaohaiyu.com/post/go-error/</link><pubDate>Sat, 22 Jan 2022 15:40:42 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-error/</guid><description>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 创建error 使用errors.New() // New returns an error that formats as the given</description></item><item><title>项目目录结构</title><link>https://www.zhaohaiyu.com/post/project-directory/</link><pubDate>Sun, 02 Jan 2022 17:03:34 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/project-directory/</guid><description>什么是DDD？ DDD 是 Domain-Driven Design 的缩写。 其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散</description></item><item><title>kratos v2版本命令行工具使用</title><link>https://www.zhaohaiyu.com/post/kratos-v2-tool/</link><pubDate>Sun, 26 Dec 2021 21:05:44 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/kratos-v2-tool/</guid><description>kratos命令行工具是什么？ kratos tool 是微服务框架 kratos 的命令行工具，提供创建模板，编译protobuf 文件，运行项目等功能。 使用 下载 go install github.com/go-kratos/kratos/cmd/kratos/v2@latest 查看是否安装成功 kratos -v kratos version v2.1.3 升级 kratos upgrade 查看帮助 kratos --help Kratos: An elegant toolkit for Go microservices. Usage: kratos [command] Available</description></item><item><title>Go泛型入门</title><link>https://www.zhaohaiyu.com/post/go-generics/</link><pubDate>Sat, 25 Dec 2021 18:17:00 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-generics/</guid><description>备注：这是一个 beta 版本的内容 这个教程介绍了 Go 泛型的基础概念。 通过泛型，你可以声明并使用函数或者是类型，那些用于调用代码时参数需要兼容多个不同类型的情况。 在这个教程里，你会声明两个普通的函数，然后复制一份</description></item><item><title>vscode常用快捷键及插件</title><link>https://www.zhaohaiyu.com/post/vscode/</link><pubDate>Mon, 20 Dec 2021 20:02:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/vscode/</guid><description>macOS 全局 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复制（未选中文本的情况下，复制光标所在行） Option + Up 向上移动行 Option +</description></item><item><title>Nethttp Gin</title><link>https://www.zhaohaiyu.com/post/nethttp-gin/</link><pubDate>Thu, 16 Dec 2021 22:09:38 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/nethttp-gin/</guid><description>net/http 路由注册 func test1() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;) }) err := http.ListenAndServe(&amp;quot;:9001&amp;quot;, nil) if err != nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li</description></item><item><title>通过 layout 探索 kratos 运行原理</title><link>https://www.zhaohaiyu.com/post/kratos-layout/</link><pubDate>Sat, 02 Oct 2021 18:03:24 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/kratos-layout/</guid><description>创建项目 首先需要安装好对应的依赖环境，以及工具： go 下载 protoc go install google.golang.org/protobuf/cmd/protoc-gen-go@latest protoc-gen-go go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest # 创建项目模板 kratos new helloworld cd helloworld # 拉取项目依赖 go mod download # 生成proto模板 kratos proto add api/helloworld/helloworld.proto # 生成proto源码 kratos proto client api/helloworld/helloworld.proto # 生成server模板 kratos proto server api/helloworld/helloworld.proto</description></item><item><title>限流</title><link>https://www.zhaohaiyu.com/post/currentlimiting/</link><pubDate>Thu, 30 Sep 2021 07:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/currentlimiting/</guid><description>令牌桶算法 是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下： 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或</description></item><item><title>隔离</title><link>https://www.zhaohaiyu.com/post/quarantine/</link><pubDate>Wed, 29 Sep 2021 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/quarantine/</guid><description>什么是隔离？ 隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。 服务隔离 动静隔离 例如 CDN 小到 CPU 的 cacheline false shari</description></item><item><title>基于 OpenTelemetry 的链路追踪</title><link>https://www.zhaohaiyu.com/post/open-telemetry/</link><pubDate>Tue, 21 Sep 2021 18:01:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/open-telemetry/</guid><description>链路追踪的前世今生 分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。 起源 链路追踪(D</description></item><item><title>Go工程化 - 依赖注入</title><link>https://www.zhaohaiyu.com/post/wire/</link><pubDate>Mon, 06 Sep 2021 16:06:42 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/wire/</guid><description>我们在微服务框架kratos v2的默认项目模板中kratos-layout使用了google/wire进行依赖注入，也建议开发者在维护项目时使用该工具。 wire 乍看起来比较违反直觉，导致很多同学不理解为什么</description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://www.zhaohaiyu.com/post/breaker/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/breaker/</guid><description>为什么要用熔断 前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。 如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本</description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://www.zhaohaiyu.com/post/overload/</link><pubDate>Sat, 04 Sep 2021 11:58:30 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/overload/</guid><description>什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达</description></item><item><title>mysql redo log和binlog</title><link>https://www.zhaohaiyu.com/post/mysql-redolog-binlog/</link><pubDate>Thu, 02 Sep 2021 16:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-redolog-binlog/</guid><description>更新语句执行流程 下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写： update T set c=c+1 where ID=2; 前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再</description></item><item><title>SQL查询语句执行流程</title><link>https://www.zhaohaiyu.com/post/mysql-exec-order/</link><pubDate>Thu, 02 Sep 2021 11:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-exec-order/</guid><description>msyql执行流程 你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：： select * from T where ID=10； 我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。 下面我给出的是 MySQL</description></item><item><title>mysql事务</title><link>https://www.zhaohaiyu.com/post/mysql-transaction/</link><pubDate>Fri, 20 Aug 2021 09:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-transaction/</guid><description>事务是什么 事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。 在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事</description></item><item><title>mysql锁</title><link>https://www.zhaohaiyu.com/post/mysql-lock/</link><pubDate>Fri, 20 Aug 2021 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-lock/</guid><description>MySQL中的锁 数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。 根据加锁的范围，MySQL</description></item><item><title>Kratos日志库的使用姿势</title><link>https://www.zhaohaiyu.com/post/kratos-log/</link><pubDate>Thu, 19 Aug 2021 18:11:50 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/kratos-log/</guid><description>什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容</description></item><item><title>RabbitMQ消息队列</title><link>https://www.zhaohaiyu.com/post/rabbitmq/</link><pubDate>Thu, 01 Jul 2021 17:40:39 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/rabbitmq/</guid><description>消息队列 本篇文章主要介绍了 RabbitMQ 这种消息队列，从消息队列的概念、应用场景、安装方式到它的核心概念、五种工作模式。在安装的时候推荐使用 Docker 方式进行安装。重点需要理解的就是消息队列的应用场景、核心概念和 RabbitMQ 的五种</description></item><item><title>grpc超时控制</title><link>https://www.zhaohaiyu.com/post/grpc-timeout/</link><pubDate>Mon, 24 May 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/grpc-timeout/</guid><description>什么是超时控制？ 超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了600ms，n那么现在已经超时，还要调用服务C等等，再返回超</description></item><item><title>grpc服务发现与负载均衡</title><link>https://www.zhaohaiyu.com/post/grpc-servicediscovery-loadbalancing/</link><pubDate>Sun, 23 May 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/grpc-servicediscovery-loadbalancing/</guid><description>前言 在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。</description></item><item><title>Go Gin框架介绍及使用</title><link>https://www.zhaohaiyu.com/post/go-gin/</link><pubDate>Sun, 09 May 2021 14:53:19 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-gin/</guid><description>Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()</description></item><item><title>Go gc垃圾回收</title><link>https://www.zhaohaiyu.com/post/go-gc/</link><pubDate>Sun, 28 Mar 2021 17:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-gc/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。 Golang中的垃圾回收主要应用三色标记法，GC</description></item><item><title>Go web源码解析</title><link>https://www.zhaohaiyu.com/post/go-net-http/</link><pubDate>Sat, 13 Mar 2021 17:35:23 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-net-http/</guid><description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;quot;/&amp;quot;, sayHello) err := http.ListenAndServe(&amp;quot;:9090&amp;quot;,nil) if err!=nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;quot;path&amp;quot;,r.URL.Path) fmt.Println(&amp;quot;scheme&amp;quot;,r.URL.Scheme) fmt.Fprintf(w, &amp;quot;Hello Guest!&amp;quot;) } 在使用ListenAndServe这个方法时，系统就会给</description></item><item><title>Http Https</title><link>https://www.zhaohaiyu.com/post/http-https/</link><pubDate>Fri, 12 Feb 2021 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/http-https/</guid><description>HTTP协议是什么？ HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。 设计HTTP最初的目的是为了提供一</description></item><item><title>分布式ID和锁</title><link>https://www.zhaohaiyu.com/post/distributed_id_lock/</link><pubDate>Sat, 23 Jan 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/distributed_id_lock/</guid><description>分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。明星</description></item><item><title>thrift的介绍及其使用</title><link>https://www.zhaohaiyu.com/post/thrift/</link><pubDate>Tue, 19 Jan 2021 20:10:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/thrift/</guid><description>什么是thrift Thrift是Facebook于2007年开发的跨语言的rpc服框架，提供多语言的编译功能，并提供多种服务器工作模式；用户通过Thrift的IDL（接口定义语言）来描述接口函数及数据</description></item><item><title>Go zap高性能日志</title><link>https://www.zhaohaiyu.com/post/go-zap/</link><pubDate>Tue, 12 Jan 2021 11:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-zap/</guid><description>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的</description></item><item><title>Go viper配置管理</title><link>https://www.zhaohaiyu.com/post/go-viper/</link><pubDate>Sat, 02 Jan 2021 11:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-viper/</guid><description>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件 3、应用程序运行过程中，保持监听和重新读取配置文件 4、可以从</description></item><item><title>Go操作redis</title><link>https://www.zhaohaiyu.com/post/go-redis/</link><pubDate>Fri, 01 Jan 2021 17:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-redis/</guid><description>安装 下载第三方包: go get -u github.com/go-redis/redis/v9 连接 // 定义一个rdis客户端 var redisdb *redis.Client // 初始化 func initClient() (err error) { redisdb = redis.NewClient(&amp;amp;redis.Options{ Addr: &amp;quot;localhost:6379&amp;quot;, // post端口 Password: &amp;quot;&amp;quot;, // 密码 DB: 0, // 使用redis的库 }) _, err = redisdb.Ping(context.Background()).Result() if err != nil { fmt.Println(&amp;quot;连接失败</description></item><item><title>Docker</title><link>https://www.zhaohaiyu.com/post/docker/</link><pubDate>Sat, 12 Dec 2020 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/docker/</guid><description>docker的定义 Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现。 docker是linux容器</description></item><item><title>grpc基础</title><link>https://www.zhaohaiyu.com/post/grpc/</link><pubDate>Sun, 29 Nov 2020 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/grpc/</guid><description>RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程</description></item><item><title>proto bufer</title><link>https://www.zhaohaiyu.com/post/protobufer/</link><pubDate>Sat, 28 Nov 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/protobufer/</guid><description>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。 protobuf介绍 Protobuf是Protocol Buffer的简称，它是Google公司于200</description></item><item><title>微服务架构及raft协议</title><link>https://www.zhaohaiyu.com/post/microservice-raft/</link><pubDate>Fri, 27 Nov 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice-raft/</guid><description>微服务架构全景图 服务注册和发现 Client side implement 调用需要维护所有调用服务的地址 有一定的技术难度，需要rpc框架支持 Server side implement 架构简单 有单点故障 注册中心 etcd注册中心 分布式一致性系统 基于raft一致性协议 etcd使用</description></item><item><title>Go HTML标签提取器soup</title><link>https://www.zhaohaiyu.com/post/go-soup/</link><pubDate>Sat, 31 Oct 2020 12:52:33 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-soup/</guid><description>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树</description></item><item><title>Go单元测试</title><link>https://www.zhaohaiyu.com/post/go-test/</link><pubDate>Wed, 28 Oct 2020 15:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-test/</guid><description>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。 go test</description></item><item><title>Go Channel</title><link>https://www.zhaohaiyu.com/post/go-channel/</link><pubDate>Tue, 27 Oct 2020 15:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-channel/</guid><description>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用</description></item><item><title>Go context包</title><link>https://www.zhaohaiyu.com/post/go-context/</link><pubDate>Sat, 24 Oct 2020 12:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-context/</guid><description>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为： 可以通过context发送取消信号。</description></item><item><title>Go Template</title><link>https://www.zhaohaiyu.com/post/go-template/</link><pubDate>Wed, 21 Oct 2020 17:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-template/</guid><description>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用te</description></item><item><title>Go Mod</title><link>https://www.zhaohaiyu.com/post/go-mod/</link><pubDate>Tue, 20 Oct 2020 17:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-mod/</guid><description>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE 要启用go module支持首先要设置环境变量GO111MODU</description></item><item><title>reids基础</title><link>https://www.zhaohaiyu.com/post/redis/</link><pubDate>Sat, 10 Oct 2020 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/redis/</guid><description>redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re</description></item><item><title>mysql索引</title><link>https://www.zhaohaiyu.com/post/mysql-index/</link><pubDate>Wed, 07 Oct 2020 11:23:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-index/</guid><description>什么是索引 一般的应用系统，都是读多写少。而且插入操作和一般的更新操作很少出现性能问题（因为有redo log锁cache缓存）。在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，</description></item><item><title>Nginx基础</title><link>https://www.zhaohaiyu.com/post/nginx/</link><pubDate>Sat, 13 Jun 2020 18:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/nginx/</guid><description>nginx是什么 nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。 支持高并发，能支持几万并发连接 资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M 可以做ht</description></item><item><title>Makefile</title><link>https://www.zhaohaiyu.com/post/makefile/</link><pubDate>Fri, 12 Jun 2020 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/makefile/</guid><description>make make是一个构建自动化工具，会在当前目录下寻找Makefile或makefile文件。如果存在相应的文件，它就会依据其中定义好的规则完成构建任务。 makefile 什么是makefile？或许很多Winodws的</description></item><item><title>Go Channel源码分析</title><link>https://www.zhaohaiyu.com/post/go-deep-channel/</link><pubDate>Tue, 31 Mar 2020 17:02:38 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-deep-channel/</guid><description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm</description></item><item><title>Go fmt包</title><link>https://www.zhaohaiyu.com/post/go-fmt/</link><pubDate>Fri, 21 Feb 2020 10:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-fmt/</guid><description>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 向外输出 标准库fmt提供了以下几种输出相关函数。 Print Print系列函数会将内容输出到系统的标</description></item><item><title>Go time包</title><link>https://www.zhaohaiyu.com/post/go-time/</link><pubDate>Thu, 20 Feb 2020 11:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-time/</guid><description>时间类型 time.Time类型表示时间。 func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;quot;Now:%v\n&amp;quot;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401 year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) // 2020-08-19 21:53:31 } 时间戳 func stamp() { now :=</description></item><item><title>MySQL数据完整性约束</title><link>https://www.zhaohaiyu.com/post/mysql-constraint/</link><pubDate>Wed, 15 Jan 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-constraint/</guid><description>主键约束 主键可以是表中的某一列，也可以是表中的多个列所构成的一个组合；其中，由多个列组合而成的主键也称为复合主键。在MySQL中，主键列必须遵守以下规则。 （1）每一个表只能定义一个主键。 （2）唯一性原</description></item><item><title>MySQL基础数据类型</title><link>https://www.zhaohaiyu.com/post/mysql-data-type/</link><pubDate>Sun, 12 Jan 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/mysql-data-type/</guid><description>数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUB</description></item><item><title>Go Map实现原理</title><link>https://www.zhaohaiyu.com/post/go-deep-map/</link><pubDate>Wed, 21 Aug 2019 16:55:50 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-deep-map/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了</description></item><item><title>Go文件系统</title><link>https://www.zhaohaiyu.com/post/go-file/</link><pubDate>Mon, 11 Feb 2019 15:36:17 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-file/</guid><description>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;quot;is not exist!&amp;quot;) return false } if os.IsNotExist(err) { return false } return true } 打开文件 f, err := os.Open(filename) if nil != err { fmt.Println(&amp;quot;open&amp;quot;, filename, &amp;quot;failed!&amp;quot;) return } defer f.Close() 如果文件不存在，就会返回错误，如果存在就以只读的方</description></item><item><title>Go Reflect</title><link>https://www.zhaohaiyu.com/post/go-reflect/</link><pubDate>Sat, 09 Feb 2019 15:18:16 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-reflect/</guid><description>变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内</description></item><item><title>Go并发</title><link>https://www.zhaohaiyu.com/post/go-concurrent/</link><pubDate>Fri, 08 Feb 2019 15:26:52 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-concurrent/</guid><description>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间</description></item><item><title>Go接口</title><link>https://www.zhaohaiyu.com/post/go-interface/</link><pubDate>Mon, 04 Feb 2019 15:22:51 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-interface/</guid><description>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 很多面向对象的语言都有相似的接口概念，但Go</description></item><item><title>Go方法</title><link>https://www.zhaohaiyu.com/post/go-method/</link><pubDate>Sat, 02 Feb 2019 15:18:16 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-method/</guid><description>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 package main import &amp;quot;fmt&amp;quot; type People struct { name string age uint8 } func (p People) SayHello() { fmt.Println(p.name, &amp;quot;: hello world&amp;quot;) p.age = 20 } func main()</description></item><item><title>Go函数</title><link>https://www.zhaohaiyu.com/post/go-function/</link><pubDate>Fri, 01 Feb 2019 15:03:51 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-function/</guid><description>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值</description></item><item><title>Go复杂数据结构</title><link>https://www.zhaohaiyu.com/post/go-complex-structure/</link><pubDate>Mon, 28 Jan 2019 20:38:18 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-complex-structure/</guid><description>数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 因为数组的长度是固定的，因此在Go语言中很少直接使用数组。 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0</description></item><item><title>Go基础类型</title><link>https://www.zhaohaiyu.com/post/go-type/</link><pubDate>Sun, 27 Jan 2019 18:22:21 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-type/</guid><description>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是</description></item><item><title>Go基础结构</title><link>https://www.zhaohaiyu.com/post/go-infrastructure/</link><pubDate>Sat, 26 Jan 2019 11:18:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go-infrastructure/</guid><description>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的字母、数字或下划线.</description></item></channel></rss>