<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>文章 on haiyux's blog</title><link>https://www.zhaohaiyu.com/post/</link><description>Recent content in 文章 on haiyux's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 12 May 2022 10:03:53 +0800</lastBuildDate><atom:link href="https://www.zhaohaiyu.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>行为模式</title><link>https://www.zhaohaiyu.com/post/designmode/behavioral/</link><pubDate>Thu, 12 May 2022 10:03:53 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/designmode/behavioral/</guid><description>责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处</description></item><item><title>结构型模式</title><link>https://www.zhaohaiyu.com/post/designmode/structure/</link><pubDate>Wed, 27 Apr 2022 15:04:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/designmode/structure/</guid><description>适配器模式 适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对json字符串进行分析等，现在有一些yaml文件也要分析，这时候我</description></item><item><title>创建者模式</title><link>https://www.zhaohaiyu.com/post/designmode/creator/</link><pubDate>Sat, 23 Apr 2022 16:28:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/designmode/creator/</guid><description>单例模式 为什么要用单例模式 保证一个对象只有一个实例 ，减少内存开销。比如一些可以复用一个连接的网络，比如http2 client等，而且可以减少</description></item><item><title>Go错误处理</title><link>https://www.zhaohaiyu.com/post/go/go-error/</link><pubDate>Sat, 22 Jan 2022 15:40:42 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-error/</guid><description>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 创</description></item><item><title>项目目录结构</title><link>https://www.zhaohaiyu.com/post/go/project-directory/</link><pubDate>Sun, 02 Jan 2022 17:03:34 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/project-directory/</guid><description>什么是DDD？ DDD 是 Domain-Driven Design 的缩写。 其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免</description></item><item><title>kratos v2版本命令行工具使用</title><link>https://www.zhaohaiyu.com/post/microservice/kratos-v2-tool/</link><pubDate>Sun, 26 Dec 2021 21:05:44 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/kratos-v2-tool/</guid><description>kratos命令行工具是什么？ kratos tool 是微服务框架 kratos 的命令行工具，提供创建模板，编译protobuf 文件，运行项目等功能。 使用 下载 go install github.com/go-kratos/kratos/cmd/kratos/v2@latest 查看是否</description></item><item><title>Go泛型入门</title><link>https://www.zhaohaiyu.com/post/go/go-generics/</link><pubDate>Sat, 25 Dec 2021 18:17:00 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-generics/</guid><description>备注：这是一个 beta 版本的内容 这个教程介绍了 Go 泛型的基础概念。 通过泛型，你可以声明并使用函数或者是类型，那些用于调用代码时参数需要兼容多个不同类</description></item><item><title>vscode常用快捷键及插件</title><link>https://www.zhaohaiyu.com/post/editor/vscode/</link><pubDate>Mon, 20 Dec 2021 20:02:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/editor/vscode/</guid><description>macOS 全局 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复</description></item><item><title>Nethttp Gin</title><link>https://www.zhaohaiyu.com/post/go/nethttp-gin/</link><pubDate>Thu, 16 Dec 2021 22:09:38 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/nethttp-gin/</guid><description>net/http 路由注册 func test1() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello world!&amp;#34;) }) err := http.ListenAndServe(&amp;#34;:9001&amp;#34;, nil) if err != nil { log.Fatal(&amp;#34;ListenAndServer:&amp;#34;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，D</description></item><item><title>通过 layout 探索 kratos 运行原理</title><link>https://www.zhaohaiyu.com/post/microservice/kratos-layout/</link><pubDate>Sat, 02 Oct 2021 18:03:24 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/kratos-layout/</guid><description>创建项目 首先需要安装好对应的依赖环境，以及工具： go 下载 protoc go install google.golang.org/protobuf/cmd/protoc-gen-go@latest protoc-gen-go go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest # 创建项目模板 kratos new helloworld cd helloworld # 拉取项目依赖 go mod download # 生成proto模板 kratos proto add</description></item><item><title>限流</title><link>https://www.zhaohaiyu.com/post/microservice/currentlimiting/</link><pubDate>Thu, 30 Sep 2021 07:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/currentlimiting/</guid><description>令牌桶算法 是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下： 假设限制2r/s，则按照500毫秒的固定速率往桶中添</description></item><item><title>隔离</title><link>https://www.zhaohaiyu.com/post/microservice/quarantine/</link><pubDate>Wed, 29 Sep 2021 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/quarantine/</guid><description>什么是隔离？ 隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其</description></item><item><title>基于 OpenTelemetry 的链路追踪</title><link>https://www.zhaohaiyu.com/post/operations/open-telemetry/</link><pubDate>Tue, 21 Sep 2021 18:01:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/operations/open-telemetry/</guid><description>链路追踪的前世今生 分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于</description></item><item><title>Go工程化 - 依赖注入</title><link>https://www.zhaohaiyu.com/post/go/wire/</link><pubDate>Mon, 06 Sep 2021 16:06:42 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/wire/</guid><description>我们在微服务框架kratos v2 的默认项目模板中kratos-layout 使用了google/wire 进行依赖注入，也建议开发者在维护项目时使</description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://www.zhaohaiyu.com/post/microservice/breaker/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/breaker/</guid><description>为什么要用熔断 前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。 如果我们服务只能处理1000QPS，但</description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://www.zhaohaiyu.com/post/microservice/overload/</link><pubDate>Sat, 04 Sep 2021 11:58:30 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/overload/</guid><description>什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监</description></item><item><title>mysql redo log和binlog</title><link>https://www.zhaohaiyu.com/post/database/mysql-redolog-binlog/</link><pubDate>Thu, 02 Sep 2021 16:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-redolog-binlog/</guid><description>更新语句执行流程 下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：</description></item><item><title>SQL查询语句执行流程</title><link>https://www.zhaohaiyu.com/post/database/mysql-exec-order/</link><pubDate>Thu, 02 Sep 2021 11:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-exec-order/</guid><description>msyql执行流程 你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：： select * from T where ID=10； 我们看到的只是输入一条语句，返回一</description></item><item><title>mysql事务</title><link>https://www.zhaohaiyu.com/post/database/mysql-transaction/</link><pubDate>Fri, 20 Aug 2021 09:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-transaction/</guid><description>事务是什么 事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。 在 MySQL 中，事务支持是在引擎层实现的。</description></item><item><title>mysql锁</title><link>https://www.zhaohaiyu.com/post/database/mysql-lock/</link><pubDate>Fri, 20 Aug 2021 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-lock/</guid><description>MySQL中的锁 数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用</description></item><item><title>Kratos日志库的使用姿势</title><link>https://www.zhaohaiyu.com/post/microservice/kratos-log/</link><pubDate>Thu, 19 Aug 2021 18:11:50 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/kratos-log/</guid><description>什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用</description></item><item><title>RabbitMQ消息队列</title><link>https://www.zhaohaiyu.com/post/database/rabbitmq/</link><pubDate>Thu, 01 Jul 2021 17:40:39 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/rabbitmq/</guid><description>消息队列 本篇文章主要介绍了 RabbitMQ 这种消息队列，从消息队列的概念、应用场景、安装方式到它的核心概念、五种工作模式。在安装的时候推荐使用 Docker 方式进行安</description></item><item><title>grpc超时控制</title><link>https://www.zhaohaiyu.com/post/microservice/grpc-timeout/</link><pubDate>Mon, 24 May 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/grpc-timeout/</guid><description>什么是超时控制？ 超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了</description></item><item><title>grpc服务发现与负载均衡</title><link>https://www.zhaohaiyu.com/post/microservice/grpc-servicediscovery-loadbalancing/</link><pubDate>Sun, 23 May 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/grpc-servicediscovery-loadbalancing/</guid><description>前言 在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直</description></item><item><title>Go Gin框架介绍及使用</title><link>https://www.zhaohaiyu.com/post/go/go-gin/</link><pubDate>Sun, 09 May 2021 14:53:19 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-gin/</guid><description>Gin框架介绍 基于httprouter 开发的Web框架。 中文文档 ，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func main()</description></item><item><title>Go gc垃圾回收</title><link>https://www.zhaohaiyu.com/post/go/go-gc/</link><pubDate>Sun, 28 Mar 2021 17:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-gc/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序</description></item><item><title>Go web源码解析</title><link>https://www.zhaohaiyu.com/post/go/go-net-http/</link><pubDate>Sat, 13 Mar 2021 17:35:23 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-net-http/</guid><description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;#34;/&amp;#34;, sayHello) err := http.ListenAndServe(&amp;#34;:9090&amp;#34;,nil) if err!=nil { log.Fatal(&amp;#34;ListenAndServer:&amp;#34;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;#34;path&amp;#34;,r.URL.Path) fmt.Println(&amp;#34;scheme&amp;#34;,r.URL.Scheme) fmt.Fprintf(w, &amp;#34;Hello</description></item><item><title>Http Https</title><link>https://www.zhaohaiyu.com/post/network/http-https/</link><pubDate>Fri, 12 Feb 2021 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/network/http-https/</guid><description>HTTP协议是什么？ HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML</description></item><item><title>分布式ID和锁</title><link>https://www.zhaohaiyu.com/post/microservice/distributed_id_lock/</link><pubDate>Sat, 23 Jan 2021 15:13:11 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/distributed_id_lock/</guid><description>分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销</description></item><item><title>thrift的介绍及其使用</title><link>https://www.zhaohaiyu.com/post/microservice/thrift/</link><pubDate>Tue, 19 Jan 2021 20:10:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/thrift/</guid><description>什么是thrift Thrift是Facebook于2007年开发的跨语言的rpc服框架，提供多语言的编译功能，并提供多种服务器工作模式；用户</description></item><item><title>Go zap高性能日志</title><link>https://www.zhaohaiyu.com/post/go/go-zap/</link><pubDate>Tue, 12 Jan 2021 11:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-zap/</guid><description>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是</description></item><item><title>Go viper配置管理</title><link>https://www.zhaohaiyu.com/post/go/go-viper/</link><pubDate>Sat, 02 Jan 2021 11:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-viper/</guid><description>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件</description></item><item><title>Go操作redis</title><link>https://www.zhaohaiyu.com/post/go/go-redis/</link><pubDate>Fri, 01 Jan 2021 17:36:55 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-redis/</guid><description>安装 下载第三方包: go get -u github.com/go-redis/redis/v9 连接 // 定义一个rdis客户端 var redisdb *redis.Client // 初始化 func initClient() (err error) { redisdb = redis.NewClient(&amp;amp;redis.Options{ Addr: &amp;#34;localhost:6379&amp;#34;, // post端口 Password: &amp;#34;&amp;#34;, // 密码 DB: 0, // 使用redis的库 }) _,</description></item><item><title>Docker</title><link>https://www.zhaohaiyu.com/post/operations/docker/</link><pubDate>Sat, 12 Dec 2020 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/operations/docker/</guid><description>docker的定义 Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。 Docker 使用</description></item><item><title>grpc基础</title><link>https://www.zhaohaiyu.com/post/microservice/grpc/</link><pubDate>Sun, 29 Nov 2020 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/grpc/</guid><description>RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/</description></item><item><title>proto bufer</title><link>https://www.zhaohaiyu.com/post/microservice/protobufer/</link><pubDate>Sat, 28 Nov 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/protobufer/</guid><description>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。 protobuf介绍 Protobuf是Pr</description></item><item><title>微服务架构及raft协议</title><link>https://www.zhaohaiyu.com/post/microservice/microservice-raft/</link><pubDate>Fri, 27 Nov 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/microservice/microservice-raft/</guid><description>微服务架构全景图 服务注册和发现 Client side implement 调用需要维护所有调用服务的地址 有一定的技术难度，需要rpc框架支持 Server side implement 架构简单 有单点故障 注册中心 etc</description></item><item><title>Go HTML标签提取器soup</title><link>https://www.zhaohaiyu.com/post/go/go-soup/</link><pubDate>Sat, 31 Oct 2020 12:52:33 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-soup/</guid><description>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(pa</description></item><item><title>Go单元测试</title><link>https://www.zhaohaiyu.com/post/go/go-test/</link><pubDate>Wed, 28 Oct 2020 15:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-test/</guid><description>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被</description></item><item><title>Go Channel</title><link>https://www.zhaohaiyu.com/post/go/go-channel/</link><pubDate>Tue, 27 Oct 2020 15:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-channel/</guid><description>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go</description></item><item><title>Go context包</title><link>https://www.zhaohaiyu.com/post/go/go-context/</link><pubDate>Sat, 24 Oct 2020 12:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-context/</guid><description>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和</description></item><item><title>Go Template</title><link>https://www.zhaohaiyu.com/post/go/go-template/</link><pubDate>Wed, 21 Oct 2020 17:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-template/</guid><description>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/templ</description></item><item><title>Go Mod</title><link>https://www.zhaohaiyu.com/post/go/go-mod/</link><pubDate>Tue, 20 Oct 2020 17:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-mod/</guid><description>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE 要</description></item><item><title>reids基础</title><link>https://www.zhaohaiyu.com/post/database/redis/</link><pubDate>Sat, 10 Oct 2020 06:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/redis/</guid><description>redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内</description></item><item><title>mysql索引</title><link>https://www.zhaohaiyu.com/post/database/mysql-index/</link><pubDate>Wed, 07 Oct 2020 11:23:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-index/</guid><description>什么是索引 一般的应用系统，都是读多写少。而且插入操作和一般的更新操作很少出现性能问题（因为有redo log锁cache缓存）。在生产环境中，</description></item><item><title>Nginx基础</title><link>https://www.zhaohaiyu.com/post/operations/nginx/</link><pubDate>Sat, 13 Jun 2020 18:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/operations/nginx/</guid><description>nginx是什么 nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。 支持高并发，能支持几万并发连接 资源消耗少，在3万并发连</description></item><item><title>Makefile</title><link>https://www.zhaohaiyu.com/post/operations/makefile/</link><pubDate>Fri, 12 Jun 2020 17:30:43 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/operations/makefile/</guid><description>make make是一个构建自动化工具，会在当前目录下寻找Makefile或makefile文件。如果存在相应的文件，它就会依据其中定义好的规则完成</description></item><item><title>Go Channel源码分析</title><link>https://www.zhaohaiyu.com/post/go/go-deep-channel/</link><pubDate>Tue, 31 Mar 2020 17:02:38 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-deep-channel/</guid><description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的gorout</description></item><item><title>Go fmt包</title><link>https://www.zhaohaiyu.com/post/go/go-fmt/</link><pubDate>Fri, 21 Feb 2020 10:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-fmt/</guid><description>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 向外输出 标准库fmt提供了以下</description></item><item><title>Go time包</title><link>https://www.zhaohaiyu.com/post/go/go-time/</link><pubDate>Thu, 20 Feb 2020 11:26:32 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-time/</guid><description>时间类型 time.Time类型表示时间。 func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;#34;Now:%v\n&amp;#34;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401 year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute()</description></item><item><title>MySQL数据完整性约束</title><link>https://www.zhaohaiyu.com/post/database/mysql-constraint/</link><pubDate>Wed, 15 Jan 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-constraint/</guid><description>主键约束 主键可以是表中的某一列，也可以是表中的多个列所构成的一个组合；其中，由多个列组合而成的主键也称为复合主键。在MySQL中，主键列必须</description></item><item><title>MySQL基础数据类型</title><link>https://www.zhaohaiyu.com/post/database/mysql-data-type/</link><pubDate>Sun, 12 Jan 2020 10:33:45 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/database/mysql-data-type/</guid><description>数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMER</description></item><item><title>Go Map实现原理</title><link>https://www.zhaohaiyu.com/post/go/go-deep-map/</link><pubDate>Wed, 21 Aug 2019 16:55:50 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-deep-map/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这</description></item><item><title>Go文件系统</title><link>https://www.zhaohaiyu.com/post/go/go-file/</link><pubDate>Mon, 11 Feb 2019 15:36:17 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-file/</guid><description>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;#34;is not exist!&amp;#34;) return false } if os.IsNotExist(err) { return false } return true } 打开文件 f, err := os.Open(filename) if nil != err { fmt.Println(&amp;#34;open&amp;#34;, filename,</description></item><item><title>Go Reflect</title><link>https://www.zhaohaiyu.com/post/go/go-reflect/</link><pubDate>Sat, 09 Feb 2019 15:18:16 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-reflect/</guid><description>变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期</description></item><item><title>Go并发</title><link>https://www.zhaohaiyu.com/post/go/go-concurrent/</link><pubDate>Fri, 08 Feb 2019 15:26:52 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-concurrent/</guid><description>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是</description></item><item><title>Go接口</title><link>https://www.zhaohaiyu.com/post/go/go-interface/</link><pubDate>Mon, 04 Feb 2019 15:22:51 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-interface/</guid><description>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和</description></item><item><title>Go方法</title><link>https://www.zhaohaiyu.com/post/go/go-method/</link><pubDate>Sat, 02 Feb 2019 15:18:16 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-method/</guid><description>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方</description></item><item><title>Go函数</title><link>https://www.zhaohaiyu.com/post/go/go-function/</link><pubDate>Fri, 01 Feb 2019 15:03:51 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-function/</guid><description>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作</description></item><item><title>Go复杂数据结构</title><link>https://www.zhaohaiyu.com/post/go/go-complex-structure/</link><pubDate>Mon, 28 Jan 2019 20:38:18 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-complex-structure/</guid><description>数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 因为数组的长度是固定的，因此在Go语言中很少直接使用数组</description></item><item><title>Go基础类型</title><link>https://www.zhaohaiyu.com/post/go/go-type/</link><pubDate>Sun, 27 Jan 2019 18:22:21 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-type/</guid><description>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别</description></item><item><title>Go基础结构</title><link>https://www.zhaohaiyu.com/post/go/go-infrastructure/</link><pubDate>Sat, 26 Jan 2019 11:18:58 +0800</pubDate><guid>https://www.zhaohaiyu.com/post/go/go-infrastructure/</guid><description>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode</description></item></channel></rss>