<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.100.2"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>grpc基础 - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta name=keywords content="微服务,protobuf,grpc"><meta property="og:title" content="grpc基础"><meta name=twitter:title content="grpc基础"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/grpc/"><meta property="og:description" content="RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程"><meta name=twitter:description content="RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2020-11-29T06:33:45+08:00"><meta property="article:modified_time" content="2020-11-29T06:33:45+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/grpc/>grpc基础</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-11-29</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2726 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;6 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1>微服务</a>&nbsp;<a href=/tags/protobuf>protobuf</a>&nbsp;<a href=/tags/grpc>grpc</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=rpc-框架原理>RPC 框架原理</h2><p>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。</p><p><img class=img-zoomable src=/img/2344773-20210820181007921-1424196285.png alt></p><p>业界主流的 RPC 框架整体上分为三类：</p><ul><li>支持多语言的 RPC 框架，比较成熟的有 Google 的 gRPC、facebook的Apache、Thrift；</li><li>只支持特定语言的 RPC 框架，例如新浪微博的 Motan；</li><li>支持服务治理等服务化特性的分布式服务框架，其底层内核仍然是 RPC 框架, 例如阿里的 Dubbo。</li></ul><h2 id=grpc是什么>gRPC是什么</h2><p><a href=http://www.oschina.net/p/grpc-framework target=_blank>gRPC</a> 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C## 支持.</p><p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p><h3 id=grc优点>grc优点</h3><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。
可插拔</li><li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li><li>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</li></ul><p><img class=img-zoomable src=/img/2344773-20210820181020505-827348595.png alt></p><h2 id=安全>安全</h2><p>HTTP2 规范当使用 TLS 时强制使用 TLS 1.2 及以上的版本，并且在部署上对允许的密码施加一些额外的限制以避免已知的比如需要 SNI 支持的问题。并且期待 HTTP2 与专有的传输安全机制相结合，这些传输机制的规格说明不能提供有意义的建议。</p><h2 id=grpc使用>gRPC使用</h2><p>使用gRPC， 我们可以一次性的在一个.proto文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑—— gRPC帮你解决了不同语言及环境间通信的复杂性。使用protocol buffers还能获得其他好处，包括高效的序列号，简单的IDL以及容易进行接口更新。总之一句话，使用gRPC能让我们更容易编写跨语言的分布式代码。</p><ul><li>通过一个 protocol buffers 模式，定义一个简单的带有 Hello World 方法的 RPC 服务。</li><li>用你最喜欢的语言(如果可用的话)来创建一个实现了这个接口的服务端。</li><li>用你最喜欢的(或者其他你愿意的)语言来访问你的服务端。</li></ul><h2 id=什么用grpc>什么用grpc</h2><ul><li>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</li><li>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML 和 Thrift。</li><li>流：Streaming API。</li><li>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</li><li>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</li><li>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</li></ul><h3 id=healthcheck>HealthCheck</h3><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p><p>主动健康检查 health check，可以在服务提供者服务不稳定时，被消费者所感知，临时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check，同样也被用于外挂方式的容器健康检测，或者流量检测(k8s liveness & readiness)。</p><p><img class=img-zoomable src=/img/2344773-20210820181031264-435404827.png alt></p><p><img class=img-zoomable src=/images/2344773-20210820181043127-1801793084-0078917.png alt></p><h2 id=protubuf文件编写>protubuf文件编写</h2><pre><code class=language-go>syntax = &quot;proto3&quot;;

package hello;

// option go_package = &quot;hello&quot;;
option go_package = &quot;/hello&quot;;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply)  {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre><h2 id=golang创建grpc-server>golang创建grpc server</h2><p>安装工具包:</p><ol><li>下载protoc <a href=https://www.zhaohaiyu.com/protobuf/ target=_blank>链接</a></li><li><code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code></li><li><code>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</code></li></ol><p>执行:</p><pre><code class=language-bash>protoc --go_out=./  --go-grpc_out=./  hello.proto
</code></pre><ul><li>&ndash;proto_path: 指定了要去哪个目录中搜索import中导入的和要编译为.go的proto文件 (在这没有使用,需要的话可以加上)</li><li>&ndash;go_out:指定了生成的go文件的目录，我在这里把go文件放到本目录中</li><li>&ndash;go-grpc_out: 指定了生成的go grpc文件的目录，我在这里把go grpc文件放到本目录中</li><li>hello.proto， 定义了我要编译的文件是哪个文件。</li></ul><h3 id=go-server代码>go server代码</h3><pre><code class=language-go>package main

import (
    &quot;context&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;github.com/zhaohaiyu1996/akit/example/grpc/hello&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;net&quot;
)

type Server struct {
    hello.UnimplementedGreeterServer
}

// SayHello implements helloworld.GreeterServer
func (s *Server) SayHello(ctx context.Context, in *hello.HelloRequest) (*hello.HelloReply, error) {
    if in.Name == &quot;error&quot; {
        return nil, errors.New(&quot;123&quot;)
    }
    if in.Name == &quot;panic&quot; {
        panic(&quot;grpc panic&quot;)
    }
    return &amp;hello.HelloReply{Message: fmt.Sprintf(&quot;Hello %+v&quot;, in.Name)}, nil
}

type Ss struct {
    *grpc.Server
}

func main() {
    // 监听本地的8848端口

    s := Ss{grpc.NewServer()}
    hello.RegisterGreeterServer(s, &amp;Server{}) // 在gRPC服务端注册服务

    lis, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8808&quot;)
    if err != nil {
        fmt.Printf(&quot;listen failed: %v&quot;, err)
        return
    }
    //reflection.Register(s.Server) //在给定的gRPC服务器上注册服务器反射服务
    // Serve方法在lis上接受传入连接，为每个连接创建一个ServerTransport和server的goroutine。
    // 该goroutine读取gRPC请求，然后调用已注册的处理程序来响应它们。
    err = s.Serve(lis)
    if err != nil {
        fmt.Printf(&quot;failed to serve: %v&quot;, err)
        return
    }
}
</code></pre><h2 id=golang创建grpc-client>golang创建grpc client</h2><p>执行:</p><pre><code class=language-bash>protoc --go_out=./  --go-grpc_out=./  hello.proto
</code></pre><h3 id=go-client代码>go client代码</h3><pre><code class=language-go>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;github.com/zhaohaiyu1996/akit/example/grpc/hello&quot;
    &quot;google.golang.org/grpc&quot;
)


func main() {
    // 连接服务器
    conn, err := grpc.Dial(&quot;localhost:8808&quot;, grpc.WithInsecure())
    if err != nil {
        fmt.Printf(&quot;connect faild: %v&quot;, err)
    }
    defer conn.Close()
    c := hello.NewGreeterClient(conn)
    // 调用SayHello
    r, err := c.SayHello(context.Background(), &amp;hello.HelloRequest{Name: &quot;zhaohaiyu&quot;})
    if err != nil {
        fmt.Printf(&quot;sayHello failed: %v&quot;, err)
    }
    fmt.Println(r)
}
</code></pre><p>结果:</p><pre><code class=language-bash>SayHello: hello ---&gt; zhaohaiyu
</code></pre><h2 id=python创建grpc-client>python创建grpc client</h2><p>使用python客户端调用golang服务端的方法</p><p>下载依赖:</p><pre><code class=language-python>pip install grpcio
pip install protobuf
pip install grpcio_tools
</code></pre><p>执行:</p><pre><code class=language-bash>python -m grpc_tools.protoc -I ./ --python_out=./ --grpc_python_out=./ hello.proto
</code></pre><h3 id=python-client代码>python client代码</h3><pre><code class=language-python>import grpc
import hello_pb2
import hello_pb2_grpc
def run():
    with grpc.insecure_channel('localhost:8848') as channel:
        stub = hello_pb2_grpc.HelloStub(channel)
        res = stub.SayHello(hello_pb2.HelloRequest(name=&quot;赵海宇&quot;))
    print(res.message)
if __name__ == '__main__':
    run()
</code></pre><p>结果:</p><pre><code class=language-bash>python ./main.go
hello ---&gt; 赵海宇
</code></pre><h2 id=gprc的haeder>gprc的haeder</h2><ul><li>grpc是基于http2.0的rpc框架 -</li><li>grpc对于http头部传递数据进行了封装 metadata,单独抽象了一个包google.golang.org/grpc/metadata-</li><li>type ***p[string][]string其实就是一个map</li></ul><p>客户端发送方式一:</p><pre><code class=language-go>// 创建md 并加入ctx
    md := metadata.Pairs(&quot;key1&quot;,&quot;value1&quot;,&quot;key2&quot;,&quot;value2&quot;)
    ctx := metadata.NewOutgoingContext(context.Background(),md)
    // 从ctx中拿出md
    md,_ = metadata.FromOutgoingContext(ctx)
    newMd := metadata.Pairs(&quot;key3&quot;,&quot;value3&quot;)
    ctx = metadata.NewOutgoingContext(ctx,metadata.Join(md,newMd))
</code></pre><p>客户端发送方式二:</p><pre><code class=language-go>ctx := context.Background()
ctx = metadata.AppendToOutgoingContext(ctx,&quot;key1&quot;,&quot;value1&quot;,&quot;key2&quot;,&quot;value2&quot;)
ctx = metadata.AppendToOutgoingContext(ctx,&quot;key3&quot;,&quot;value3&quot;)
</code></pre><p>服务端接收:</p><pre><code class=language-go>md,ok := metadata.FromIncomingContext(ctx)
</code></pre><p>实例:</p><ol><li>server:</li></ol><pre><code class=language-go>package main
import (
    &quot;fmt&quot;
    &quot;net&quot;
    pb &quot;test/demo13/server/hello&quot;
    &quot;github.com/grpc-ecosystem/grpc-gateway/examples/clients/responsebody&quot;
    &quot;github.com/uber/jaeger-client-go/crossdock/client&quot;
    &quot;golang.org/x/net/context&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/metadata&quot;
    &quot;google.golang.org/grpc/reflection&quot;
)
type server struct{}
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {

    md,ok := metadata.FromIncomingContext(ctx)
    if ok {
        fmt.Println(md)
    }
    return &amp;pb.HelloResponse{Message: &quot;hello ---&gt; &quot; + in.Name}, nil
}
func main() {
    // 监听本地的8848端口
    lis, err := net.Listen(&quot;tcp&quot;, &quot;localhost:8848&quot;)
    if err != nil {
        fmt.Printf(&quot;listen failed: %v&quot;, err)
        return
    }
    s := grpc.NewServer() // 创建gRPC服务器
    pb.RegisterHelloServer(s, &amp;server{}) // 在gRPC服务端注册服务
    reflection.Register(s) //在给定的gRPC服务器上注册服务器反射服务
    // Serve方法在lis上接受传入连接，为每个连接创建一个ServerTransport和server的goroutine。
    // 该goroutine读取gRPC请求，然后调用已注册的处理程序来响应它们。
    err = s.Serve(lis)
    if err != nil {
        fmt.Printf(&quot;failed to serve: %v&quot;, err)
        return
    }
}
</code></pre><ol><li>client</li></ol><pre><code class=language-go>package main
import (
    &quot;context&quot;
    &quot;fmt&quot;
    pb &quot;test/demo13/client/hello&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/metadata&quot;
)
func main() {
    // 连接服务器
    conn, err := grpc.Dial(&quot;localhost:8848&quot;, grpc.WithInsecure())
    if err != nil {
        fmt.Printf(&quot;faild to connect: %v&quot;, err)
    }
    defer conn.Close()
    c := pb.NewHelloClient(conn)
    // 调用服务端的SayHello
    ctx := context.Background()
    ctx = metadata.AppendToOutgoingContext(ctx,&quot;zhyyz&quot;,&quot;961119&quot;)
    r, err := c.SayHello(ctx, &amp;pb.HelloRequest{Name: &quot;zhaohaiyu&quot;})
    if err != nil {
        fmt.Printf(&quot;sayHello failed: %v&quot;, err)
    }
    fmt.Printf(&quot;SayHello: %s \n&quot;, r.Message)
}
</code></pre></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector('.post-comment'),t=document.body.getAttribute('data-theme');t==='auto'?t=window.matchMedia('(prefers-color-scheme: dark)').matches?'photon-dark':'github-light':t=t==='dark'?'photon-dark':'github-light',e=document.createElement('script'),e.src='https://utteranc.es/client.js',e.setAttribute('repo','haiyux/haiyux.github.io'),e.setAttribute('issue-term','pathname'),e.setAttribute('theme',t),e.setAttribute('crossorigin','anonymous'),e.setAttribute('async',''),document.querySelector('.post-comment').appendChild(e),document.querySelector('span.post-comment-notloaded').setAttribute('style','display: none;')}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=mailto:haiyux@foxmail.com target=_blank><span>Email</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#rpc-框架原理>RPC 框架原理</a></li><li><a href=#grpc是什么>gRPC是什么</a><ul><li><a href=#grc优点>grc优点</a></li></ul></li><li><a href=#安全>安全</a></li><li><a href=#grpc使用>gRPC使用</a></li><li><a href=#什么用grpc>什么用grpc</a><ul><li><a href=#healthcheck>HealthCheck</a></li></ul></li><li><a href=#protubuf文件编写>protubuf文件编写</a></li><li><a href=#golang创建grpc-server>golang创建grpc server</a><ul><li><a href=#go-server代码>go server代码</a></li></ul></li><li><a href=#golang创建grpc-client>golang创建grpc client</a><ul><li><a href=#go-client代码>go client代码</a></li></ul></li><li><a href=#python创建grpc-client>python创建grpc client</a><ul><li><a href=#python-client代码>python client代码</a></li></ul></li><li><a href=#gprc的haeder>gprc的haeder</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=mailto:haiyux@foxmail.com target=_blank><span>Email</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#rpc-框架原理>RPC 框架原理</a></li><li><a href=#grpc是什么>gRPC是什么</a><ul><li><a href=#grc优点>grc优点</a></li></ul></li><li><a href=#安全>安全</a></li><li><a href=#grpc使用>gRPC使用</a></li><li><a href=#什么用grpc>什么用grpc</a><ul><li><a href=#healthcheck>HealthCheck</a></li></ul></li><li><a href=#protubuf文件编写>protubuf文件编写</a></li><li><a href=#golang创建grpc-server>golang创建grpc server</a><ul><li><a href=#go-server代码>go server代码</a></li></ul></li><li><a href=#golang创建grpc-client>golang创建grpc client</a><ul><li><a href=#go-client代码>go client代码</a></li></ul></li><li><a href=#python创建grpc-client>python创建grpc client</a><ul><li><a href=#python-client代码>python client代码</a></li></ul></li><li><a href=#gprc的haeder>gprc的haeder</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://github.com/haiyux/haiyu.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>