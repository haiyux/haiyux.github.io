<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=x-ua-compatible content="IE=edge"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=generator content="Hugo 0.100.2"><link rel=apple-touch-icon sizes=180x180 href=/img/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><link rel=manifest href=/img/site.webmanifest><link rel=mask-icon href=/img/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>reids基础 - 赵海宇的博客</title><meta name=author content="haiyux"><meta name=description content="欢迎来到haiyux的博客"><meta name=keywords content="redis"><meta property="og:title" content="reids基础"><meta name=twitter:title content="reids基础"><meta property="og:type" content="article"><meta property="og:url" content="https://www.zhaohaiyu.com/post/redis/"><meta property="og:description" content="redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re"><meta name=twitter:description content="redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re"><meta property="og:image" content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.zhaohaiyu.com/img/favicon-32x32.png"><meta property="article:published_time" content="2020-10-10T06:33:45+08:00"><meta property="article:modified_time" content="2020-10-10T06:33:45+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://www.zhaohaiyu.com/assets/css/fuji.min.css></head><body data-theme=auto data-theme-auto=true><script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://www.zhaohaiyu.com>赵海宇的博客</a>
<span class=title-sub>路漫漫其修远兮,吾将上下而求索。</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://www.zhaohaiyu.com/post/redis/>reids基础</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-10-10</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;7579 字</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;16 分钟</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/redis>redis</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=redis介绍>redis介绍</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id=redis的安装>redis的安装</h3><pre><code class=language-bash>brew install redis(mac)
yum install redis(centos)
apt-get install redis(ubuntu)
</code></pre><h2 id=redis的命令网站>redis的命令网站</h2><p><a href=http://doc.redisfans.com/ target=_blank>Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><h2 id=redis的基本操作>redis的基本操作</h2><h3 id=redis的五大数据类型>redis的五大数据类型</h3><p>redis的五大数据类型是: <strong>String(字符串)、Hash(哈希)、List(列表)、Set(集合)、和zset(sorted set:有序集合)</strong></p><h3 id=redis键操作>redis键操作</h3><ul><li><code>keys *</code>查看当前库所有key (匹配：keys *1)</li><li><code>exists key</code>判断某个key是否存在</li><li><code>type key</code> 查看你的key是什么类型</li><li><code>del key</code> 删除指定的key数据</li><li><code>unlink key</code> 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><code>expire key 10</code> 10秒钟：为给定的key设置过期时间</li><li><code>ttl key</code> 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>select</code>命令切换数据库</li><li><code>dbsize</code>查看当前数据库的key的数量</li><li><code>flushdb</code>清空当前库</li><li><code>flushall</code>通杀全部库</li></ul><h3 id=字符串string>字符串(String)</h3><h4 id=简介>简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><h4 id=常用命令>常用命令</h4><ul><li><code>set &lt;key>&lt;value></code>添加键值对</li><li><code>get &lt;key></code>查询对应键值</li><li><code>append &lt;key>&lt;value></code>将给定的<value> 追加到原值的末尾</li><li><code>strlen &lt;key></code>获得值的长度</li><li><code>setnx &lt;key>&lt;value></code>只有在 key 不存在时 设置 key 的值</li><li><code>incr &lt;key> </code>将 key 中储存的数字值增1 只能对数字值操作，如果为空，新增值为1</li><li><code>decr &lt;key></code> 将 key 中储存的数字值减1 只能对数字值操作，如果为空，新增值为-1</li><li><code>incrby / decrby &lt;key>&lt;步长></code>将 key 中储存的数字值增减。自定义步长。</li></ul><h4 id=数据结构>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img class=img-zoomable src=/images/2344773-20210822104121617-1543511327.png alt></p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id=列表list>列表(List)</h3><h4 id=简介-1>简介</h4><p>单键多值</p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img class=img-zoomable src=/images/2344773-20210822104142657-469194505.png alt></p><h4 id=常用命令-1>常用命令</h4><ul><li><code>lpush/rpush &lt;key>&lt;value1>&lt;value2>&lt;value3> ....</code> 从左边/右边插入一个或多个值。</li><li><code>lpop/rpop &lt;key></code>从左边/右边吐出一个值。值在键在，值光键亡。</li><li><code>rpoplpush &lt;key1>&lt;key2></code>从<key1>列表右边吐出一个值，插到<key2>列表左边。</li><li><code>lrange &lt;key>&lt;start>&lt;stop></code> 按照索引下标获得元素(从左到右)</li><li><code>lrange mylist 0 -1</code> 0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li><code>lindex &lt;key>&lt;index></code>按照索引下标获得元素(从左到右)</li><li><code>llen &lt;key></code>获得列表长度</li><li><code>linsert &lt;key> before &lt;value>&lt;newvalue></code>在<value>的后面插入<newvalue>插入值</li><li><code>lrem &lt;key>&lt;n>&lt;value></code>从左边删除n个value(从左到右)</li><li><code>lset&lt;key>&lt;index>&lt;value></code>将列表key下标为index的值替换成value</li></ul><h4 id=数据结构-1>数据结构</h4><p>List的数据结构为快速链表quickList。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img class=img-zoomable src=/images/2344773-20210822104154068-1490126321.png alt></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id=集合set>集合(Set)</h3><h4 id=简介-2>简介</h4><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以****自动排重****的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的****复杂度都是O(1)****。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h4 id=常用命令-2>常用命令</h4><ul><li><code>sadd &lt;key>&lt;value1>&lt;value2> ..... </code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li><code>smembers &lt;key></code>取出该集合的所有值。</li><li><code>sismember &lt;key>&lt;value></code>判断集合<key>是否为含有该<value>值，有1，没有0</li><li><code>scard&lt;key></code>返回该集合的元素个数。</li><li><code>srem &lt;key>&lt;value1>&lt;value2> ....</code> 删除集合中的某个元素。</li><li><code>spop &lt;key></code><em><strong>*随机从该集合中吐出一个值。*</strong></em></li><li><code>srandmember &lt;key>&lt;n></code>随机从该集合中取出n个值。不会从集合中删除 。</li><li><code>smove &lt;source>&lt;destination></code>value把集合中一个值从一个集合移动到另一个集合</li><li><code>sinter &lt;key1>&lt;key2></code>返回两个集合的交集元素。</li><li><code>sunion &lt;key1>&lt;key2></code>返回两个集合的并集元素。</li><li><code>sdiff &lt;key1>&lt;key2></code>返回两个集合的****差集****元素(key1中的，不包含key2中的)</li></ul><h4 id=数据结构-2>数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。
Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id=哈希hash>哈希(Hash)</h3><h4 id=简介-3>简介</h4><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><h4 id=常用命令-3>常用命令</h4><ul><li><code>hset &lt;key>&lt;field>&lt;value></code>给<key>集合中的 <field>键赋值<value></li><li><code>hget &lt;key1>&lt;field></code>从<key1>集合<field>取出 value</li><li><code>hmset &lt;key1>&lt;field1>&lt;value1>&lt;field2>&lt;value2>... </code>批量设置hash的值</li><li><code>hexists&lt;key1>&lt;field></code>查看哈希表 key 中，给定域 field 是否存在。</li><li><code>hkeys &lt;key></code>列出该hash集合的所有field</li><li><code>hvals &lt;key></code>列出该hash集合的所有value</li><li><code>hincrby &lt;key>&lt;field>&lt;increment></code>为哈希表 key 中的域 field 的值加上增量 1 -1</li><li><code>hsetnx &lt;key>&lt;field>&lt;value></code>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li></ul><h4 id=数据结构-3>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id=有序集合zsetsorted-set>有序集合Zset(sorted set)</h3><h4 id=简介-4>简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个****评分（score）****,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id=常用命令-4>常用命令</h4><ul><li><code>zadd &lt;key>&lt;score1>&lt;value1>&lt;score2>&lt;value2>… </code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li><code>zrange &lt;key>&lt;start>&lt;stop> [WITHSCORES]</code> 返回有序集 key 中，下标在<start><stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。</li><li><code>zrangebyscore key minmax [withscores] [limit offset count]</code> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li><li><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code> 同上，改为从大到小排列。</li><li><code>zincrby &lt;key>&lt;increment>&lt;value></code> 为元素的score加上增量</li><li><code>zrem &lt;key>&lt;value></code>删除该集合下，指定值的元素</li><li><code>zcount &lt;key>&lt;min>&lt;max></code>统计该集合，分数区间内的元素个数</li><li><code>zrank &lt;key>&lt;value></code>返回该值在集合中的排名，从0开始。</li></ul><h4 id=数据结构-4>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构</p><ol><li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><h2 id=redis新数据类型>Redis新数据类型</h2><h3 id=bitmaps>Bitmaps</h3><h4 id=简介-5>简介</h4><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p><p><img class=img-zoomable src=/images/2344773-20210822104217377-993547167.png alt></p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img class=img-zoomable src=/images/2344773-20210822104229331-33955654.png alt></p><h4 id=命令>命令</h4><ol><li>setbit</li></ol><p>（1）格式</p><p><code>setbit&lt;key>&lt;offset>&lt;value></code>设置Bitmaps中某个偏移量的值（0或1）</p><p><img class=img-zoomable src=/images/2344773-20210822104240133-810682231.png alt></p><p>*offset:偏移量从0开始</p><p>（2）实例</p><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p><p><img class=img-zoomable src=/images/2344773-20210822104254299-1643973179.png alt></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p><p><img class=img-zoomable src=/images/2344773-20210822104303999-1626642786.png alt></p><p>注：</p><p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p><ol start=2><li>getbit</li></ol><p>（1）格式
getbit<key><offset>获取Bitmaps中某个偏移量的值</p><p>获取键的第offset位的值（从0开始算）</p><p>（2）实例
获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过</p><p><img class=img-zoomable src=/images/2344773-20210822104318020-1492153741.png alt></p><p>注：因为100根本不存在，所以也是返回0</p><ol start=3><li>bitcount</li></ol><p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。
（1）格式
bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p><p>（2）实例
计算2022-11-06这天的独立访问用户数量</p><p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p><pre><code>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】
bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000
--》bitcount K1 1 2 　　--》1

bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001
--》bitcount K1 1 3　　--》3

bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000
--》bitcount K1 0 -2　　--》3
</code></pre><p>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p><ol start=4><li>bitop</li></ol><p>(1)格式
bitop and(or/not/xor) <destkey>[key…]</p><p><img class=img-zoomable src=/images/2344773-20210822104347550-1602906251.png alt></p><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><p>(2)实例</p><p>2020-11-04 日访问网站的userid=1,2,5,9。</p><p>setbit unique:users:20201104 1 1</p><p>setbit unique:users:20201104 2 1</p><p>setbit unique:users:20201104 5 1</p><p>setbit unique:users:20201104 9 1</p><p>2020-11-03 日访问网站的userid=0,1,4,9。</p><p>setbit unique:users:20201103 0 1</p><p>setbit unique:users:20201103 1 1</p><p>setbit unique:users:20201103 4 1</p><p>setbit unique:users:20201103 9 1</p><p>计算出两天都访问过网站的用户数量</p><p>bitop and unique:users:and:20201104_03</p><p>unique:users:20201103unique:users:20201104</p><p><img class=img-zoomable src=/images/2344773-20210822104409205-112998705.png alt></p><p><img class=img-zoomable src=/images/2344773-20210822104423561-1297650702.png alt></p><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p><p><img class=img-zoomable src=/images/2344773-20210822104435961-48187161.png alt></p><h4 id=bitmaps与set对比>Bitmaps与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><h3 id=hyperloglog>HyperLogLog</h3><h4 id=简介-6>简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。
但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。
解决基数问题有很多种方案：
（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id=命令-1>命令</h4><p>1、pfadd</p><p>（1）格式</p><p>pfadd <key>&lt; element> [element &mldr;] 添加指定元素到 HyperLogLog 中</p><p><img class=img-zoomable src=/images/2344773-20210822104453962-1987702553.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/2344773-20210822104511571-1054685663.png alt></p><pre><code>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。
</code></pre><p>2、pfcount</p><p>（1）格式</p><p>pfcount<key> [key &mldr;] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p><p><img class=img-zoomable src=/images/2344773-20210822104523019-1060895308.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/2344773-20210822104557594-209731117.png alt></p><p>3、pfmerge</p><p>（1）格式</p><p>pfmerge<destkey><sourcekey> [sourcekey &mldr;] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p><p><img class=img-zoomable src=/images/2344773-20210822104657581-1072488082.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/2344773-20210822104708122-225764470.png alt></p><h3 id=geospatial>Geospatial</h3><h4 id=简介-7>简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id=命令-2>命令</h4><p>1、geoadd</p><p>（1）格式</p><p>geoadd<key>&lt; longitude><latitude><member> [longitude latitude member&mldr;] 添加地理位置（经度，纬度，名称）</p><p><img class=img-zoomable src=/images/2344773-20210822104721907-2118360636.png alt></p><p>2）实例</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p><img class=img-zoomable src=/images/2344773-20210822104736859-685047335.png alt></p><p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p><p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>已经添加的数据，是无法再次往里面添加的。</p><p>2、geopos</p><p>（1）格式</p><p>geopos <key><member>[member&mldr;] 获得指定地区的坐标值</p><p><img class=img-zoomable src=/images/2344773-20210822104753243-512291139.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/2344773-20210822104802897-75505679.png alt></p><p>3、geodist</p><p>（1）格式</p><p>geodist<key><member1><member2> [m|km|ft|mi ] 获取两个位置之间的直线距离</p><p><img class=img-zoomable src=/images/2344773-20210822104816935-1672928435.png alt></p><p>（2）实例</p><p>获取两个位置之间的直线距离</p><p><img class=img-zoomable src=/images/2344773-20210822104826840-448574183.png alt></p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p><p>4、georadius</p><p>（1）格式</p><p>georadius<key>&lt; longitude><latitude>radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素</p><p><img class=img-zoomable src=/images/2344773-20210822104839952-1368013784.png alt></p><p>经度 纬度 距离 单位</p><p>（2）实例</p><p><img class=img-zoomable src=/images/2344773-20210822104848997-1956452627.png alt></p></div></article><div class="license markdown-body"><blockquote><p>除特殊注明部分，本站内容采用 <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 进行许可。</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;查看评论</span>
<script>function loadComment(){var e,n=document.querySelector('.post-comment'),t=document.body.getAttribute('data-theme');t==='auto'?t=window.matchMedia('(prefers-color-scheme: dark)').matches?'photon-dark':'github-light':t=t==='dark'?'photon-dark':'github-light',e=document.createElement('script'),e.src='https://utteranc.es/client.js',e.setAttribute('repo','haiyux/haiyux.github.io'),e.setAttribute('issue-term','pathname'),e.setAttribute('theme',t),e.setAttribute('crossorigin','anonymous'),e.setAttribute('async',''),document.querySelector('.post-comment').appendChild(e),document.querySelector('span.post-comment-notloaded').setAttribute('style','display: none;')}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#redis介绍>redis介绍</a><ul><li><a href=#redis的安装>redis的安装</a></li></ul></li><li><a href=#redis的命令网站>redis的命令网站</a></li><li><a href=#redis的基本操作>redis的基本操作</a><ul><li><a href=#redis的五大数据类型>redis的五大数据类型</a></li><li><a href=#redis键操作>redis键操作</a></li><li><a href=#字符串string>字符串(String)</a></li><li><a href=#列表list>列表(List)</a></li><li><a href=#集合set>集合(Set)</a></li><li><a href=#哈希hash>哈希(Hash)</a></li><li><a href=#有序集合zsetsorted-set>有序集合Zset(sorted set)</a></li></ul></li><li><a href=#redis新数据类型>Redis新数据类型</a><ul><li><a href=#bitmaps>Bitmaps</a></li><li><a href=#hyperloglog>HyperLogLog</a></li><li><a href=#geospatial>Geospatial</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>页面</h3><ul><li><a href=/>主页</a></li><li><a href=/archives/>文章</a></li><li><a href=/about/>关于</a></li><li><a href=/search/>搜索</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>链接</h3><ul><li><a href=https://github.com/haiyux target=_blank><span>GitHub</span></a></li><li><a href=https://go-kratos.dev target=_blank><span>Kratos</span></a></li><li><a href=https://farer.org/ target=_blank><span>Windfarer</span></a></li><li><a href=https://www.liwenzhou.com/ target=_blank><span>李文周</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>标签</h3><div><span><a href=/tags/ddd/>DDD</a></span>
<span><a href=/tags/docker/>docker</a></span>
<span><a href=/tags/golang/>golang</a></span>
<span><a href=/tags/grpc/>grpc</a></span>
<span><a href=/tags/http/>http</a></span>
<span><a href=/tags/kratos/>kratos</a></span>
<span><a href=/tags/makefile/>makefile</a></span>
<span><a href=/tags/mq/>mq</a></span>
<span><a href=/tags/mysql/>mysql</a></span>
<span><a href=/tags/nginx/>nginx</a></span>
<span><a href=/tags/protobuf/>protobuf</a></span>
<span><a href=/tags/raft/>raft</a></span>
<span><a href=/tags/redis/>redis</a></span>
<span><a href=/tags/thrift/>Thrift</a></span>
<span><a href=/tags/traceing/>traceing</a></span>
<span><a href=/tags/wire/>wire</a></span>
<span><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></span>
<span><a href=/tags/%E6%B3%9B%E5%9E%8B/>泛型</a></span>
<span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span><a href=/tags/%E8%BF%90%E7%BB%B4/>运维</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>目录</h3><nav id=TableOfContents><ul><li><a href=#redis介绍>redis介绍</a><ul><li><a href=#redis的安装>redis的安装</a></li></ul></li><li><a href=#redis的命令网站>redis的命令网站</a></li><li><a href=#redis的基本操作>redis的基本操作</a><ul><li><a href=#redis的五大数据类型>redis的五大数据类型</a></li><li><a href=#redis键操作>redis键操作</a></li><li><a href=#字符串string>字符串(String)</a></li><li><a href=#列表list>列表(List)</a></li><li><a href=#集合set>集合(Set)</a></li><li><a href=#哈希hash>哈希(Hash)</a></li><li><a href=#有序集合zsetsorted-set>有序集合Zset(sorted set)</a></li></ul></li><li><a href=#redis新数据类型>Redis新数据类型</a><ul><li><a href=#bitmaps>Bitmaps</a></li><li><a href=#hyperloglog>HyperLogLog</a></li><li><a href=#geospatial>Geospatial</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2022
<a href=https://www.zhaohaiyu.com>haiyux</a>
| <a href=https://github.com/haiyux/haiyu.github.io>Source code</a>
| 基于 <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a> 构建</span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script></body></html>